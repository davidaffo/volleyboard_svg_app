/*
  AUTO-GENERATED FILE
  Source of truth: web/index.html, web/style.css, web/app.js
  Regenerate with: node scripts/sync-plugin.js
*/
const { Plugin, Notice } = require('obsidian');

const WEB_HTML = "<header class=\"topbar\">\n    <div class=\"brand\">\n      <span class=\"dot\"></span>\n      <span class=\"title\">VolleyBoard</span>\n    </div>\n    <div class=\"toolbar\">\n      <button id=\"btnAddPlayer\" class=\"btn\" title=\"Aggiungi giocatore\">+ Giocatore</button>\n      <button id=\"btnArrow\" class=\"btn\" title=\"Disegna frecce\">↗ Frecce</button>\n      <button id=\"btnText\" class=\"btn\" title=\"Aggiungi testo\">T</button>\n      <button id=\"btnRotateACW\" class=\"btn\" title=\"Ruota squadra A (orario)\">↻ A</button>\n      <button id=\"btnRotateACCW\" class=\"btn\" title=\"Ruota squadra A (antiorario)\">↺ A</button>\n      <button id=\"btnRotateBCW\" class=\"btn\" title=\"Ruota squadra B (orario)\">↻ B</button>\n      <button id=\"btnRotateBCCW\" class=\"btn\" title=\"Ruota squadra B (antiorario)\">↺ B</button>\n      <label class=\"zoomControl\" title=\"Zoom\">\n        <span>Zoom</span>\n        <input id=\"zoomSlider\" type=\"range\" min=\"50\" max=\"200\" step=\"5\" value=\"100\" />\n      </label>\n      <button id=\"btnUndo\" class=\"btn\" title=\"Annulla\">↶</button>\n      <button id=\"btnRedo\" class=\"btn\" title=\"Ripristina\">↷</button>\n      <button id=\"btnReset\" class=\"btn btnDanger\" title=\"Reset\">Reset</button>\n      <button id=\"btnExportImg\" class=\"btn\" title=\"Esporta immagine PNG\">Immagine</button>\n      <button id=\"btnExport\" class=\"btn\" title=\"Esporta JSON\">Export</button>\n      <button id=\"btnImport\" class=\"btn\" title=\"Importa JSON\">Import</button>\n    </div>\n  </header>\n\n  <main class=\"main\">\n    <aside class=\"toolbox\">\n      <div class=\"panel toolboxPanel\">\n        <div class=\"panelTitle\">Strumenti</div>\n        <div class=\"toolGrid\" id=\"toolGrid\"></div>\n      </div>\n    </aside>\n    <section class=\"stageWrap\">\n      <div class=\"layoutTabs\" id=\"layoutTabs\" role=\"tablist\">\n        <button class=\"tab isActive\" data-layout=\"full-h\" role=\"tab\">Campo intero</button>\n        <button class=\"tab\" data-layout=\"half\" role=\"tab\">Mezzo campo</button>\n      </div>\n      <div class=\"stage\" id=\"stage\"></div>\n      <button class=\"rotateBtn rotateLeft\" id=\"btnRotateLeft\" type=\"button\" title=\"Ruota sinistra\">↺</button>\n      <button class=\"rotateBtn rotateRight\" id=\"btnRotateRight\" type=\"button\" title=\"Ruota destra\">↻</button>\n      <div class=\"inspectorOverlay\" id=\"inspectorOverlay\">\n        <div class=\"overlayHeader\" id=\"inspectorHandle\">Oggetto selezionato</div>\n        <div id=\"inspector\" class=\"inspector\">\n          <div class=\"muted\">Nessuna selezione</div>\n        </div>\n      </div>\n      <div class=\"hud\" id=\"hud\">\n        <div class=\"hudRow\">\n          <span class=\"chip\" id=\"chipMode\">Modalità: Selezione</span>\n          <span class=\"chip\" id=\"chipZoom\">Zoom: 100%</span>\n        </div>\n        <div class=\"hudRow\">\n          <span class=\"hint\">Drag: sposta oggetti • Pinch/Alt+wheel: zoom • Space+drag: pan • Tap lungo: menu</span>\n        </div>\n      </div>\n      <div class=\"ctxMenu\" id=\"ctxMenu\" hidden></div>\n    </section>\n\n    <aside class=\"side\">\n      <div class=\"panel\">\n        <div class=\"panelTitle\">Aggiungi giocatore per ruolo</div>\n        <div class=\"formGrid\">\n          <div class=\"label\">Squadra</div>\n          <select id=\"addTeam\"></select>\n          <div class=\"label\">Ruolo</div>\n          <select id=\"addRole\"></select>\n          <div class=\"label\">Numero</div>\n          <input id=\"addNumber\" type=\"text\" placeholder=\"Es. 7\" />\n          <button id=\"btnAddRolePlayer\" class=\"btn btnPrimary full\">Aggiungi</button>\n        </div>\n      </div>\n\n      <div class=\"panel\">\n        <div class=\"panelTitle\">Squadre di default</div>\n        <div class=\"presetGrid\">\n          <button class=\"btn\" data-preset=\"teamA\">Solo squadra A</button>\n          <button class=\"btn\" data-preset=\"teamB\">Solo squadra B</button>\n          <button class=\"btn\" data-preset=\"teams\">A + B (6 vs 6)</button>\n          <button class=\"btn\" data-preset=\"empty\">Campo vuoto</button>\n        </div>\n      </div>\n\n      <div class=\"panel\">\n        <div class=\"panelTitle\">Note</div>\n        <textarea id=\"notes\" class=\"notes\" placeholder=\"Annotazioni libere (salvate nello stato)...\"></textarea>\n      </div>\n\n      <div class=\"panel\">\n        <div class=\"panelTitle\">Stato</div>\n        <div class=\"kv\">\n          <div class=\"k\">Oggetti</div><div class=\"v\" id=\"statObjects\">0</div>\n          <div class=\"k\">Layer</div><div class=\"v\">Giocatori • Palla • Disegni • Testo</div>\n          <div class=\"k\">Formato</div><div class=\"v\">SVG + JSON</div>\n        </div>\n      </div>\n    </aside>\n  </main>\n\n  <dialog id=\"dlgIO\" class=\"dlg\">\n    <form method=\"dialog\" class=\"dlgForm\">\n      <div class=\"dlgTitle\" id=\"dlgTitle\">Import/Export</div>\n      <textarea id=\"ioText\" class=\"ioText\" spellcheck=\"false\"></textarea>\n      <div class=\"dlgActions\">\n        <button value=\"cancel\" class=\"btn\">Chiudi</button>\n        <button id=\"btnIOMain\" value=\"ok\" class=\"btn btnPrimary\">OK</button>\n      </div>\n    </form>\n  </dialog>\n\n  <dialog id=\"dlgMenu\" class=\"dlg\">\n    <form method=\"dialog\" class=\"dlgForm small\">\n      <div class=\"dlgTitle\">Azioni</div>\n      <div class=\"menuGrid\" id=\"menuGrid\"></div>\n      <div class=\"dlgActions\">\n        <button value=\"cancel\" class=\"btn\">Chiudi</button>\n      </div>\n    </form>\n  </dialog>";
const WEB_CSS = "/* VolleyBoard minimal UI */\n:root{\n  --bg:#0d0f12;\n  --panel:#11141a;\n  --panel2:#0f1217;\n  --text:#e7eaf0;\n  --muted:#9aa3b2;\n  --accent:#5eead4;\n  --danger:#ef4444;\n  --stroke:#2a3240;\n  --btn:#1a2130;\n  --btn2:#212a3c;\n  --shadow: 0 10px 30px rgba(0,0,0,.35);\n  --radius:14px;\n  --radius2:18px;\n  --gap:12px;\n  --font: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Arial;\n}\n*{box-sizing:border-box}\nhtml,body{height:100%}\nbody{\n  margin:0;\n  font-family:var(--font);\n  color:var(--text);\n  background: radial-gradient(1200px 800px at 20% 20%, #12202a 0%, var(--bg) 60%);\n  overflow:hidden;\n}\n.topbar{\n  position:sticky; top:0;\n  z-index:10;\n  display:flex;\n  align-items:center;\n  justify-content:space-between;\n  padding:10px 12px;\n  background: rgba(13,15,18,.75);\n  backdrop-filter: blur(10px);\n  border-bottom:1px solid rgba(255,255,255,.06);\n}\n.brand{display:flex; gap:10px; align-items:center}\n.brand .dot{width:10px;height:10px;border-radius:50%; background:var(--accent); box-shadow:0 0 18px rgba(94,234,212,.5)}\n.brand .title{font-weight:700; letter-spacing:.2px}\n.toolbar{display:flex; gap:8px; flex-wrap:wrap; justify-content:flex-end}\n.zoomControl{\n  display:flex;\n  align-items:center;\n  gap:6px;\n  padding:6px 10px;\n  border-radius:12px;\n  background: rgba(0,0,0,.25);\n  border:1px solid rgba(255,255,255,.08);\n  color:var(--muted);\n  font-size:12px;\n}\n.zoomControl input[type=\"range\"]{\n  width:120px;\n}\n.btn{\n  background:linear-gradient(180deg,var(--btn2),var(--btn));\n  border:1px solid rgba(255,255,255,.08);\n  color:var(--text);\n  padding:8px 10px;\n  border-radius:12px;\n  cursor:pointer;\n  box-shadow: 0 8px 18px rgba(0,0,0,.25);\n  user-select:none;\n  touch-action:manipulation;\n}\n.btn:active{transform: translateY(1px)}\n.btnPrimary{border-color: rgba(94,234,212,.25)}\n.btnDanger{border-color: rgba(239,68,68,.25)}\n.main{\n  display:grid;\n  grid-template-columns: 220px 1fr 320px;\n  gap:var(--gap);\n  padding:var(--gap);\n  height: calc(100% - 58px);\n}\n.toolbox{\n  display:flex;\n  flex-direction:column;\n  gap:var(--gap);\n  height:100%;\n  min-width:0;\n}\n.toolboxPanel{\n  display:flex;\n  flex-direction:column;\n  gap:10px;\n  height:100%;\n}\n.toolGrid{\n  display:grid;\n  grid-template-columns: repeat(3, minmax(0, 1fr));\n  gap:6px;\n  overflow:auto;\n  max-height:100%;\n  padding-right:2px;\n}\n.toolBtn{\n  background:linear-gradient(180deg,var(--btn2),var(--btn));\n  border:1px solid rgba(255,255,255,.08);\n  color:var(--text);\n  border-radius:14px;\n  aspect-ratio: 1 / 1;\n  display:flex;\n  flex-direction:column;\n  align-items:center;\n  justify-content:center;\n  gap:3px;\n  cursor:grab;\n  box-shadow: 0 8px 18px rgba(0,0,0,.25);\n  user-select:none;\n}\n.toolBtn:active{transform: translateY(1px)}\n.toolIcon{\n  font-weight:800;\n  font-size:14px;\n  letter-spacing:.2px;\n}\n.toolPreview{\n  width:46px;\n  height:46px;\n  display:block;\n}\n.toolLabel{\n  font-size:11px;\n  color:var(--muted);\n  text-align:center;\n  padding:0 6px;\n}\n.toolLabel{\n  font-size:11px;\n  color:var(--muted);\n  text-align:center;\n  padding:0 6px;\n}\n.toolSwatch{\n  width:18px;\n  height:16px;\n  clip-path: polygon(50% 0, 100% 100%, 0 100%);\n  border-radius:2px;\n  background: var(--swatch, #f97316);\n  box-shadow: inset 0 -2px 0 rgba(0,0,0,.25);\n}\n.stageWrap{\n  position:relative;\n  min-width:0;\n  display:flex;\n  flex-direction:column;\n  min-height:0;\n}\n.layoutTabs{\n  display:flex;\n  gap:8px;\n  flex-wrap:wrap;\n  margin-bottom:10px;\n}\n.tabGroup{\n  display:flex;\n  gap:6px;\n  align-items:center;\n}\n.tab{\n  background:linear-gradient(180deg,var(--btn2),var(--btn));\n  border:1px solid rgba(255,255,255,.08);\n  color:var(--text);\n  padding:7px 10px;\n  border-radius:999px;\n  cursor:pointer;\n  font-size:12px;\n  letter-spacing:.2px;\n}\n.tabSmall{\n  padding:6px 9px;\n  font-size:11px;\n}\n.tab.isActive{\n  border-color: rgba(94,234,212,.35);\n  box-shadow: 0 8px 18px rgba(94,234,212,.18);\n}\n.rotateBtn{\n  position:absolute;\n  top:50%;\n  transform: translateY(-50%);\n  width:36px;\n  height:36px;\n  border-radius:50%;\n  border:1px solid rgba(255,255,255,.12);\n  background: rgba(17,20,26,.75);\n  color:var(--text);\n  cursor:pointer;\n  z-index:6;\n  box-shadow: var(--shadow);\n  backdrop-filter: blur(8px);\n}\n.rotateBtn:active{transform: translateY(-50%) scale(0.98)}\n.rotateLeft{left:12px}\n.rotateRight{right:12px}\n.stage{\n  width:100%;\n  height:100%;\n  flex:1;\n  background:linear-gradient(180deg, #2d9848, #1f502c);\n  border:1px solid rgba(255,255,255,.07);\n  border-radius: var(--radius2);\n  box-shadow: var(--shadow);\n  overflow:hidden;\n  position:relative;\n  touch-action:none;\n  overscroll-behavior: none;\n}\n.stage svg{touch-action:none}\n.inspectorOverlay{\n  position:absolute;\n  top:16px;\n  right:16px;\n  width:min(280px, calc(100% - 32px));\n  background: rgba(17,20,26,.85);\n  border:1px solid rgba(255,255,255,.08);\n  border-radius: 14px;\n  box-shadow: var(--shadow);\n  padding:10px;\n  z-index:5;\n  backdrop-filter: blur(10px);\n}\n.overlayHeader{\n  font-weight:700;\n  margin-bottom:8px;\n  cursor:move;\n  user-select:none;\n  touch-action:none;\n}\n.hud{\n  position:absolute;\n  left:18px;\n  bottom:18px;\n  right:18px;\n  display:flex;\n  flex-direction:column;\n  gap:8px;\n  pointer-events:none;\n}\n.ctxMenu{\n  position:absolute;\n  min-width:220px;\n  max-width:320px;\n  background: rgba(17,20,26,.95);\n  border:1px solid rgba(255,255,255,.08);\n  border-radius: 14px;\n  box-shadow: var(--shadow);\n  padding:10px;\n  z-index:9;\n  backdrop-filter: blur(10px);\n}\n.ctxMenu .menuTitle{\n  font-weight:800;\n  margin-bottom:8px;\n}\n.ctxMenu .menuRow{\n  display:grid;\n  grid-template-columns: 90px 1fr;\n  gap:8px;\n  align-items:center;\n  margin:6px 0;\n}\n.ctxMenu .menuLabel{\n  color:var(--muted);\n  font-size:12px;\n}\n.ctxMenu input,.ctxMenu select{\n  width:100%;\n  background: rgba(0,0,0,.25);\n  border:1px solid rgba(255,255,255,.10);\n  color:var(--text);\n  padding:6px 8px;\n  border-radius:10px;\n  outline:none;\n  font-size:14px;\n}\n.ctxMenu .menuActions{\n  display:flex;\n  gap:8px;\n  margin-top:8px;\n  flex-wrap:wrap;\n}\n.hudRow{display:flex; gap:10px; align-items:center; flex-wrap:wrap}\n.chip{\n  pointer-events:none;\n  padding:6px 10px;\n  border-radius:999px;\n  background: rgba(17,20,26,.65);\n  border:1px solid rgba(255,255,255,.08);\n  color: var(--text);\n  font-size:12px;\n  backdrop-filter: blur(10px);\n}\n.hint{\n  font-size:12px;\n  color:var(--muted);\n  padding:6px 10px;\n  border-radius:999px;\n  background: rgba(17,20,26,.55);\n  border:1px solid rgba(255,255,255,.06);\n  backdrop-filter: blur(10px);\n}\n.side{\n  display:flex;\n  flex-direction:column;\n  gap:var(--gap);\n  height:100%;\n  min-width:0;\n}\n.panel{\n  background: rgba(17,20,26,.7);\n  border:1px solid rgba(255,255,255,.07);\n  border-radius: var(--radius2);\n  box-shadow: var(--shadow);\n  padding:12px;\n  overflow:auto;\n}\n.panelTitle{font-weight:700; margin-bottom:10px}\n.inspector .row{display:grid; grid-template-columns: 96px 1fr; gap:10px; align-items:center; margin:8px 0}\n.inspector .label{color:var(--muted); font-size:12px}\n.inspector input,.inspector select{\n  width:100%;\n  background: rgba(0,0,0,.25);\n  border:1px solid rgba(255,255,255,.10);\n  color:var(--text);\n  padding:8px 10px;\n  border-radius:12px;\n  outline:none;\n  font-size:16px;\n}\n.muted{color:var(--muted); font-size:13px}\n.presetGrid{display:grid; grid-template-columns:1fr 1fr; gap:8px}\n.formGrid{display:grid; grid-template-columns: 96px 1fr; gap:8px; align-items:center}\n.formGrid .label{color:var(--muted); font-size:12px}\n.formGrid input,.formGrid select{\n  width:100%;\n  background: rgba(0,0,0,.25);\n  border:1px solid rgba(255,255,255,.10);\n  color:var(--text);\n  padding:8px 10px;\n  border-radius:12px;\n  outline:none;\n  font-size:16px;\n}\n.formGrid .full{grid-column:1/-1}\n.notes{\n  width:100%;\n  min-height:120px;\n  resize:vertical;\n  background: rgba(0,0,0,.25);\n  border:1px solid rgba(255,255,255,.10);\n  color:var(--text);\n  padding:10px 12px;\n  border-radius:12px;\n  outline:none;\n}\n.kv{display:grid; grid-template-columns: 90px 1fr; gap:8px; font-size:13px}\n.k{color:var(--muted)}\n.dlg::backdrop{background: rgba(0,0,0,.6)}\n.dlg{\n  border:none;\n  border-radius: var(--radius2);\n  padding:0;\n  width:min(860px, calc(100vw - 24px));\n  box-shadow: var(--shadow);\n  background: rgba(17,20,26,.95);\n  color: var(--text);\n}\n.dlgForm{display:flex; flex-direction:column; gap:10px; padding:14px}\n.dlgForm.small{width:min(520px, calc(100vw - 24px))}\n.dlgTitle{font-weight:800}\n.ioText{\n  width:100%;\n  height: min(520px, 56vh);\n  resize:vertical;\n  background: rgba(0,0,0,.35);\n  border:1px solid rgba(255,255,255,.10);\n  color:var(--text);\n  padding:10px 12px;\n  border-radius:12px;\n  outline:none;\n  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, \"Liberation Mono\", \"Courier New\", monospace;\n  font-size:12px;\n  line-height:1.4;\n}\n.dlgActions{display:flex; justify-content:flex-end; gap:10px}\n.menuGrid{display:grid; grid-template-columns: 1fr 1fr; gap:8px}\n@media (max-width: 980px){\n  body{overflow:auto}\n  .main{grid-template-columns: 1fr; height:auto}\n  .stage{height: 62vh; min-height: 420px}\n}\n";
const WEB_JS = "(() => {\n  'use strict';\n\n  const $ = (sel, root=document) => root.querySelector(sel);\n  const $$ = (sel, root=document) => Array.from(root.querySelectorAll(sel));\n\n  // Coordinate system: court in logical units: width=18, height=9.\n  // SVG viewBox includes some margin: [-1,-1] -> [20,11]\n  const COURT_W = 18;\n  const COURT_H = 9;\n\n  const defaultRotationFor = (layoutId) => (layoutId === 'full-v' ? 90 : (layoutId === 'half' ? 270 : 0));\n\n\n  const LAYOUTS = {\n    'full-h': { id: 'full-h', label: 'Campo intero', view: { x: -2, y: -2, w: 22, h: 13 } },\n    'full-v': { id: 'full-v', label: 'Campo intero (vert.)', view: { x: -2, y: -2, w: 13, h: 22 } },\n    'half': { id: 'half', label: 'Mezzo campo', view: { x: -1, y: -1, w: 11, h: 11 } },\n  };\n\n  const DEFAULT_STATE = () => ({\n    version: 1,\n    meta: { createdAt: new Date().toISOString() },\n    layout: 'full-h',\n    rotation: 0,\n    view: { x: -1, y: -1, w: 20, h: 11 }, // viewBox\n    notes: '',\n    layers: { players: true, drawings: true, text: true },\n    objects: [], // {id,type,team,x,y,role,label,style,...}\n    drawings: [], // {id,type,path,team,style}\n    texts: [], // {id,type,x,y,text,team,style}\n    props: [], // {id,type,kind,x,y,role,color}\n    selection: [],\n  });\n\n  const ID = () => 'id_' + Math.random().toString(16).slice(2) + '_' + Date.now().toString(16);\n\n  const TEAMS = [\n    { id: 'A', name: 'Squadra A' },\n    { id: 'B', name: 'Squadra B' },\n  ];\n\n  const ROLES = [\n    { id: 'P', name: 'Palleggiatore (P)' },\n    { id: 'S1', name: 'Schiacciatore 1 (S1)' },\n    { id: 'C2', name: 'Centrale 2 (C2)' },\n    { id: 'O', name: 'Opposto (O)' },\n    { id: 'S2', name: 'Schiacciatore 2 (S2)' },\n    { id: 'C1', name: 'Centrale 1 (C1)' },\n    { id: 'X', name: 'Altro (X)' },\n  ];\n\n  const TOOLBOX_ITEMS = [\n    { id:'role-P', label:'P', kind:'player', role:'P' },\n    { id:'role-S1', label:'S1', kind:'player', role:'S1' },\n    { id:'role-C2', label:'C2', kind:'player', role:'C2' },\n    { id:'role-O', label:'O', kind:'player', role:'O' },\n    { id:'role-S2', label:'S2', kind:'player', role:'S2' },\n    { id:'role-C1', label:'C1', kind:'player', role:'C1' },\n    { id:'ball', label:'Palla', kind:'ball' },\n    { id:'cone-red', label:'Cinesino rosso', kind:'cone', color:'#ef4444' },\n    { id:'cone-yellow', label:'Cinesino giallo', kind:'cone', color:'#f59e0b' },\n    { id:'cone-blue', label:'Cinesino blu', kind:'cone', color:'#3b82f6' },\n    { id:'cone-green', label:'Cinesino verde', kind:'cone', color:'#10b981' },\n    { id:'ball-cart', label:'Carrello palloni', kind:'ball-cart', previewScale: 0.8 },\n    { id:'basket', label:'Canestro', kind:'basket', previewScale: 0.8 },\n    { id:'coach', label:'Allenatore', kind:'coach' },\n    { id:'ladder', label:'Scaletta', kind:'ladder', previewScale: 0.6 },\n    { id:'target', label:'Bersaglio', kind:'target' },\n  ];\n\n\n  const EMBEDDED = !!window.VOLLEY_EMBED;\n  const changeListeners = new Set();\n\n  function emitChange() {\n    if (!changeListeners.size) return;\n    const payload = serializeState();\n    for (const cb of changeListeners) {\n      try { cb(payload); } catch {}\n    }\n  }\n\n  // Undo/redo\n  const history = [];\n  const future = [];\n  const pushHistory = (state) => {\n    history.push(JSON.stringify(state));\n    if (history.length > 200) history.shift();\n    future.length = 0;\n  };\n  const undo = () => {\n    if (history.length <= 1) return null;\n    const cur = history.pop();\n    future.push(cur);\n    return JSON.parse(history[history.length - 1]);\n  };\n  const redo = () => {\n    if (future.length === 0) return null;\n    const next = future.pop();\n    history.push(next);\n    return JSON.parse(next);\n  };\n\n  // Mode\n  const MODE = {\n    SELECT: 'select',\n    ARROW: 'arrow',\n    TEXT: 'text',\n    PAN: 'pan',\n  };\n\n  let state = DEFAULT_STATE();\n  state.layoutStates = {};\n  ensureLayoutState(state.layout);\n  bindLayoutState(state.layout);\n  pushHistory(state);\n\n  const stage = $('#stage');\n  const inspector = $('#inspector');\n  const inspectorOverlay = $('#inspectorOverlay');\n  const inspectorHandle = $('#inspectorHandle');\n  const notesEl = $('#notes');\n  const statObjects = $('#statObjects');\n  const chipMode = $('#chipMode');\n  const chipZoom = $('#chipZoom');\n  const toolGrid = $('#toolGrid');\n  const zoomSlider = $('#zoomSlider');\n  const ENABLE_LONG_PRESS_MENU = false;\n\n  // Build SVG\n  const svgNS = 'http://www.w3.org/2000/svg';\n  const svg = document.createElementNS(svgNS, 'svg');\n  svg.setAttribute('class', 'vb');\n  svg.setAttribute('width', '100%');\n  svg.setAttribute('height', '100%');\n  svg.setAttribute('viewBox', `${state.view.x} ${state.view.y} ${state.view.w} ${state.view.h}`);\n  svg.setAttribute('role', 'img');\n  svg.setAttribute('tabindex', '0');\n  svg.style.touchAction = 'none';\n\n  const defs = document.createElementNS(svgNS, 'defs');\n  defs.innerHTML = `\n    <linearGradient id=\"bgFullH\" x1=\"0\" y1=\"0\" x2=\"1\" y2=\"1\">\n      <stop offset=\"0%\" stop-color=\"#f6a12a\"></stop>\n      <stop offset=\"100%\" stop-color=\"#db6b06\"></stop>\n    </linearGradient>\n    <linearGradient id=\"bgFullV\" x1=\"0\" y1=\"1\" x2=\"1\" y2=\"0\">\n      <stop offset=\"0%\" stop-color=\"#f2a136\"></stop>\n      <stop offset=\"100%\" stop-color=\"#d46305\"></stop>\n    </linearGradient>\n    <linearGradient id=\"bgHalfH\" x1=\"0\" y1=\"0\" x2=\"1\" y2=\"0\">\n      <stop offset=\"0%\" stop-color=\"#f4a738\"></stop>\n      <stop offset=\"100%\" stop-color=\"#d76a08\"></stop>\n    </linearGradient>\n    <linearGradient id=\"bgHalfV\" x1=\"0\" y1=\"0\" x2=\"0\" y2=\"1\">\n      <stop offset=\"0%\" stop-color=\"#f6a73e\"></stop>\n      <stop offset=\"100%\" stop-color=\"#d06005\"></stop>\n    </linearGradient>\n    <clipPath id=\"clipFull\" clipPathUnits=\"userSpaceOnUse\">\n      <rect x=\"0\" y=\"0\" width=\"18\" height=\"9\" rx=\"0.4\"></rect>\n    </clipPath>\n    <clipPath id=\"clipHalf\" clipPathUnits=\"userSpaceOnUse\">\n      <rect x=\"0\" y=\"0\" width=\"9\" height=\"9\" rx=\"0.4\"></rect>\n    </clipPath>\n    <marker id=\"arrowHead\" viewBox=\"0 0 10 10\" refX=\"8.5\" refY=\"5\" markerWidth=\"6\" markerHeight=\"6\" orient=\"auto-start-reverse\">\n      <path d=\"M 0 0 L 10 5 L 0 10 z\" fill=\"currentColor\"></path>\n    </marker>\n  `;\n  svg.appendChild(defs);\n\n  const gRoot = document.createElementNS(svgNS, 'g');\n  const gScene = document.createElementNS(svgNS, 'g');\n  const gCourt = document.createElementNS(svgNS, 'g');\n  const gDrawings = document.createElementNS(svgNS, 'g');\n  const gProps = document.createElementNS(svgNS, 'g');\n  const gPlayers = document.createElementNS(svgNS, 'g');\n  const gText = document.createElementNS(svgNS, 'g');\n  const gHandles = document.createElementNS(svgNS, 'g');\n\n  gRoot.setAttribute('id', 'root');\n  gScene.setAttribute('id', 'scene');\n  gCourt.setAttribute('id', 'court');\n  gDrawings.setAttribute('id', 'drawings');\n  gProps.setAttribute('id', 'props');\n  gPlayers.setAttribute('id', 'players');\n  gText.setAttribute('id', 'textLayer');\n  gHandles.setAttribute('id', 'handles');\n\n  svg.appendChild(gRoot);\n  gRoot.appendChild(gScene);\n  gScene.appendChild(gCourt);\n  gScene.appendChild(gDrawings);\n  gScene.appendChild(gProps);\n  gScene.appendChild(gPlayers);\n  gScene.appendChild(gText);\n  gScene.appendChild(gHandles);\n\n  stage.appendChild(svg);\n\n  // Court drawing\n  function drawCourt() {\n    gCourt.innerHTML = '';\n    const isHalf = state.layout === 'half';\n    const courtW = isHalf ? COURT_W / 2 : COURT_W;\n    const netX = isHalf ? courtW : COURT_W / 2;\n    const angle = ((state.rotation % 360) + 360) % 360;\n    const isVertical = angle === 90 || angle === 270;\n    const bgId = state.layout === 'half'\n      ? (isVertical ? 'bgHalfV' : 'bgHalfH')\n      : (isVertical ? 'bgFullV' : 'bgFullH');\n    const court = (tag, attrs={}) => {\n      const el = document.createElementNS(svgNS, tag);\n      for (const [k,v] of Object.entries(attrs)) el.setAttribute(k, String(v));\n      gCourt.appendChild(el);\n      return el;\n    };\n\n    // Background\n    court('rect', { x: 0, y: 0, width: courtW, height: COURT_H, rx: 0.4, fill: `url(#${bgId})` });\n    court('rect', { x: 0, y: 0, width: courtW, height: COURT_H, rx: 0.4, fill: 'rgba(255,255,255,0.04)' });\n    // Border\n    court('rect', { x: 0, y: 0, width: courtW, height: COURT_H, fill: 'none', stroke: 'rgba(255,255,255,0.9)', 'stroke-width': 0.08 });\n\n    // Net (midline for full court, boundary for half court)\n    if (!isHalf) {\n      court('line', { x1: netX, y1: 0, x2: netX, y2: COURT_H, stroke: 'rgba(255,255,255,0.9)', 'stroke-width': 0.08 });\n    }\n    court('rect', { x: netX - 0.06, y: 0, width: 0.12, height: COURT_H, fill: 'rgba(255,255,255,0.12)' });\n\n    // 3m lines (3m from net)\n    court('line', { x1: netX - 3, y1: 0, x2: netX - 3, y2: COURT_H, stroke: 'rgba(255,255,255,0.9)', 'stroke-width': 0.06, 'stroke-dasharray': '0.25 0.25' });\n    if (!isHalf) {\n      court('line', { x1: netX + 3, y1: 0, x2: netX + 3, y2: COURT_H, stroke: 'rgba(255,255,255,0.9)', 'stroke-width': 0.06, 'stroke-dasharray': '0.25 0.25' });\n    }\n  }\n\n  drawCourt();\n\n  // Helpers\n  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));\n\n  function defaultLayoutState(layoutId) {\n    const baseView = LAYOUTS[layoutId]?.view || LAYOUTS['full-h'].view;\n    const defaultRotation = defaultRotationFor(layoutId);\n    return {\n      view: { ...baseView },\n      rotation: defaultRotation,\n      notes: '',\n      objects: [],\n      drawings: [],\n      texts: [],\n      props: [],\n      selection: [],\n    };\n  }\n\n  function ensureLayoutState(layoutId) {\n    if (!state.layoutStates) state.layoutStates = {};\n    if (!state.layoutStates[layoutId]) state.layoutStates[layoutId] = defaultLayoutState(layoutId);\n    if (!state.layoutStates[layoutId].view) {\n      state.layoutStates[layoutId].view = { ...(LAYOUTS[layoutId]?.view || LAYOUTS['full-h'].view) };\n    }\n    if (typeof state.layoutStates[layoutId].rotation !== 'number') {\n      state.layoutStates[layoutId].rotation = defaultRotationFor(layoutId);\n    }\n    if (!state.layoutStates[layoutId].props) state.layoutStates[layoutId].props = [];\n  }\n\n  function bindLayoutState(layoutId) {\n    ensureLayoutState(layoutId);\n    const ls = state.layoutStates[layoutId];\n    const baseView = LAYOUTS[layoutId]?.view || LAYOUTS['full-h'].view;\n    const isHalf = layoutId === 'half';\n    if (isHalf) {\n      ls.view = { ...baseView };\n    } else if (!ls.view || ls.view.w > baseView.w * 1.05 || ls.view.h > baseView.h * 1.05) {\n      ls.view = { ...baseView };\n    }\n    state.view = ls.view;\n    if (typeof ls.rotation === 'number') state.rotation = ls.rotation;\n    state.notes = ls.notes || '';\n    state.objects = ls.objects || [];\n    state.drawings = ls.drawings || [];\n    state.texts = ls.texts || [];\n    state.props = ls.props || [];\n    // ball is now a prop; legacy data handled in migrateLegacyBall()\n    state.selection = normalizeSelection(ls.selection);\n  }\n\n  function syncLayoutState() {\n    const ls = state.layoutStates?.[state.layout];\n    if (!ls) return;\n    ls.view = state.view;\n    ls.rotation = state.rotation;\n    ls.notes = state.notes || '';\n    ls.selection = normalizeSelection(state.selection);\n    ls.objects = state.objects || [];\n    ls.drawings = state.drawings || [];\n    ls.texts = state.texts || [];\n    ls.props = state.props || [];\n  }\n\n  function getBaseView() {\n    const isHalf = state.layout === 'half';\n    if (isHalf) return LAYOUTS['half'].view;\n    const angle = ((state.rotation % 360) + 360) % 360;\n    const isVertical = angle === 90 || angle === 270;\n    return isVertical ? LAYOUTS['full-v'].view : LAYOUTS['full-h'].view;\n  }\n\n  function setViewBox(v) {\n    const layout = LAYOUTS[state.layout] || LAYOUTS['full-h'];\n    const isHalf = state.layout === 'half';\n    const baseView = getBaseView();\n    const nextView = v;\n    state.view = nextView;\n    svg.setAttribute('viewBox', `${nextView.x} ${nextView.y} ${nextView.w} ${nextView.h}`);\n    const zoom = baseView.w / nextView.w;\n    chipZoom.textContent = `Zoom: ${Math.round(zoom*100)}%`;\n    if (zoomSlider) zoomSlider.value = String(Math.round(zoom*100));\n  }\n\n  function applyLayoutTransform() {\n    const isHalf = state.layout === 'half';\n    const w = isHalf ? COURT_W / 2 : COURT_W;\n    const h = COURT_H;\n    const angle = ((state.rotation % 360) + 360) % 360;\n    if (angle === 90) {\n      gScene.setAttribute('transform', `translate(${h} 0) rotate(90)`);\n    } else if (angle === 180) {\n      gScene.setAttribute('transform', `translate(${w} ${h}) rotate(180)`);\n    } else if (angle === 270) {\n      gScene.setAttribute('transform', `translate(0 ${w}) rotate(270)`);\n    } else {\n      gScene.removeAttribute('transform');\n    }\n    gRoot.removeAttribute('clip-path');\n  }\n\n  function setLayout(layoutId) {\n    syncLayoutState();\n    const layout = LAYOUTS[layoutId] || LAYOUTS['full-h'];\n    state.layout = layout.id;\n    bindLayoutState(layout.id);\n    state.view = { ...getBaseView() };\n    setViewBox({ ...state.view });\n    applyLayoutTransform();\n    updateLayoutTabs();\n    commit();\n  }\n\n  function updateLayoutTabs() {\n    $$('.layoutTabs .tab').forEach((btn) => {\n      const layoutId = btn.getAttribute('data-layout');\n      const isActive = layoutId ? layoutId === state.layout : false;\n      btn.classList.toggle('isActive', isActive);\n    });\n  }\n\n  function applyLayerVisibility() {\n    gPlayers.style.display = state.layers.players ? '' : 'none';\n    gDrawings.style.display = state.layers.drawings ? '' : 'none';\n    gText.style.display = state.layers.text ? '' : 'none';\n  }\n\n  function teamColor(teamId) {\n    // Use currentColor on elements; we set style color on group/items\n    return teamId === 'A' ? 'rgba(94,234,212,0.95)' : 'rgba(244,114,182,0.95)';\n  }\n\n  function currentCourtBounds() {\n    return { maxX: state.view.x + state.view.w, maxY: state.view.y + state.view.h, minX: state.view.x, minY: state.view.y };\n  }\n\n  function objById(id) {\n    if (!id) return null;\n    return state.objects.find(o => o.id === id)\n      || state.drawings.find(d => d.id === id)\n      || state.texts.find(t => t.id === id)\n      || state.props.find(p => p.id === id);\n  }\n\n  function normalizeSelection(sel) {\n    if (Array.isArray(sel)) return sel.filter(Boolean);\n    if (sel) return [sel];\n    return [];\n  }\n\n  function getSelection() {\n    return normalizeSelection(state.selection);\n  }\n\n  function setSelection(ids) {\n    const next = Array.from(new Set(normalizeSelection(ids)));\n    state.selection = next;\n    const ls = state.layoutStates?.[state.layout];\n    if (ls) ls.selection = next;\n    render();\n  }\n\n  function clearSelection() {\n    setSelection([]);\n  }\n\n  function toggleSelection(id) {\n    if (!id) return;\n    const sel = new Set(getSelection());\n    if (sel.has(id)) sel.delete(id);\n    else sel.add(id);\n    setSelection([...sel]);\n  }\n\n  function isSelected(id) {\n    return getSelection().includes(id);\n  }\n\n  function primarySelection() {\n    const sel = getSelection();\n    return sel.length ? sel[sel.length - 1] : null;\n  }\n\n  function getTransformableSelection() {\n    return getSelection()\n      .map((id) => objById(id))\n      .filter((o) => o && (o.type === 'player' || o.type === 'text' || o.type === 'prop'))\n      .map((o) => ({ id: o.id, x: o.x, y: o.y, rotation: o.rotation || 0, scale: o.scale || 1 }));\n  }\n\n  function svgPointFromClient(clientX, clientY) {\n    const pt = svg.createSVGPoint();\n    pt.x = clientX;\n    pt.y = clientY;\n    const ctm = gScene.getScreenCTM();\n    if (!ctm) return { x: 0, y: 0 };\n    const inv = ctm.inverse();\n    const p = pt.matrixTransform(inv);\n    return { x: p.x, y: p.y };\n  }\n\n  // Rendering\n  function renderPlayers() {\n    gPlayers.innerHTML = '';\n    const angle = ((state.rotation % 360) + 360) % 360;\n    for (const o of state.objects) {\n      if (o.type !== 'player') continue;\n\n      const g = document.createElementNS(svgNS, 'g');\n      g.setAttribute('data-id', o.id);\n      const rot = o.rotation || 0;\n      const scale = o.scale || 1;\n      g.setAttribute('transform', `translate(${o.x} ${o.y}) rotate(${rot}) scale(${scale})`);\n      g.style.color = teamColor(o.team);\n      g.style.cursor = 'grab';\n\n      const base = document.createElementNS(svgNS, 'circle');\n      base.setAttribute('cx', '0');\n      base.setAttribute('cy', '0');\n      base.setAttribute('r', '0.3');\n      base.setAttribute('fill', 'currentColor');\n      base.setAttribute('stroke', 'rgba(0,0,0,0.25)');\n      base.setAttribute('stroke-width', '0.03');\n      g.appendChild(base);\n\n      const highlight = document.createElementNS(svgNS, 'circle');\n      highlight.setAttribute('cx', '-0.1');\n      highlight.setAttribute('cy', '-0.1');\n      highlight.setAttribute('r', '0.045');\n      highlight.setAttribute('fill', 'rgba(255,255,255,.25)');\n      g.appendChild(highlight);\n\n      const overrideVal = (o.overrideText || '').trim();\n      const labelVal = (o.label || '').trim();\n      const roleVal = (o.role || '').trim();\n      const showBigLabel = labelVal && !roleVal;\n      const showBigRole = roleVal && !labelVal;\n\n      if (overrideVal) {\n        const big = document.createElementNS(svgNS, 'text');\n        big.setAttribute('x', '0');\n        big.setAttribute('y', '0');\n        big.setAttribute('text-anchor', 'middle');\n        big.setAttribute('dominant-baseline', 'middle');\n        big.setAttribute('font-size', '0.32');\n        big.setAttribute('fill', 'rgba(255,255,255,0.96)');\n        big.setAttribute('stroke', 'rgba(0,0,0,0.45)');\n        big.setAttribute('stroke-width', '0.03');\n        big.setAttribute('paint-order', 'stroke');\n        big.setAttribute('font-weight', '700');\n        big.style.pointerEvents = 'none';\n        if (angle || rot) big.setAttribute('transform', `rotate(${-(angle) + rot})`);\n        big.textContent = overrideVal;\n        g.appendChild(big);\n      } else if (showBigLabel || showBigRole) {\n        const big = document.createElementNS(svgNS, 'text');\n        big.setAttribute('x', '0');\n        big.setAttribute('y', '0');\n        big.setAttribute('text-anchor', 'middle');\n        big.setAttribute('dominant-baseline', 'middle');\n        big.setAttribute('font-size', '0.32');\n        big.setAttribute('fill', 'rgba(255,255,255,0.96)');\n        big.setAttribute('stroke', 'rgba(0,0,0,0.45)');\n        big.setAttribute('stroke-width', '0.03');\n        big.setAttribute('paint-order', 'stroke');\n        big.setAttribute('font-weight', '700');\n        big.style.pointerEvents = 'none';\n        if (angle || rot) big.setAttribute('transform', `rotate(${-(angle) + rot})`);\n        big.textContent = showBigLabel ? labelVal : roleVal;\n        g.appendChild(big);\n      } else {\n        const txt = document.createElementNS(svgNS, 'text');\n        txt.setAttribute('x', '0');\n        txt.setAttribute('y', '-0.06');\n        txt.setAttribute('text-anchor', 'middle');\n        txt.setAttribute('font-size', '0.23');\n        txt.setAttribute('fill', 'rgba(255,255,255,0.96)');\n        txt.setAttribute('stroke', 'rgba(0,0,0,0.45)');\n        txt.setAttribute('stroke-width', '0.03');\n        txt.setAttribute('paint-order', 'stroke');\n        txt.setAttribute('font-weight', '700');\n        txt.style.pointerEvents = 'none';\n        if (angle || rot) txt.setAttribute('transform', `rotate(${-(angle) + rot})`);\n        txt.textContent = labelVal;\n        g.appendChild(txt);\n\n        const role = document.createElementNS(svgNS, 'text');\n        role.setAttribute('x', '0');\n        role.setAttribute('y', '0.18');\n        role.setAttribute('text-anchor', 'middle');\n        role.setAttribute('font-size', '0.17');\n        role.setAttribute('fill', 'rgba(255,255,255,0.9)');\n        role.setAttribute('stroke', 'rgba(0,0,0,0.45)');\n        role.setAttribute('stroke-width', '0.03');\n        role.setAttribute('paint-order', 'stroke');\n        role.setAttribute('font-weight', '700');\n        role.style.pointerEvents = 'none';\n        if (angle || rot) role.setAttribute('transform', `rotate(${-(angle) + rot})`);\n        role.textContent = roleVal;\n        g.appendChild(role);\n      }\n\n      if (isSelected(o.id)) {\n        const sel = document.createElementNS(svgNS, 'circle');\n        sel.setAttribute('cx', '0');\n        sel.setAttribute('cy', '0');\n        sel.setAttribute('r', '0.4');\n        sel.setAttribute('fill', 'none');\n        sel.setAttribute('stroke', 'rgba(255,255,255,0.65)');\n        sel.setAttribute('stroke-width', '0.06');\n        sel.style.pointerEvents = 'none';\n        g.insertBefore(sel, base);\n      }\n\n      gPlayers.appendChild(g);\n    }\n  }\n\n  function drawPropShape(g, p) {\n    const add = (tag, attrs={}) => {\n      const el = document.createElementNS(svgNS, tag);\n      for (const [k,v] of Object.entries(attrs)) el.setAttribute(k, String(v));\n      g.appendChild(el);\n      return el;\n    };\n\n    if (p.kind === 'player') {\n      add('circle', { cx:0, cy:0, r:0.32, fill:'rgba(94,234,212,0.9)', stroke:'rgba(0,0,0,0.25)', 'stroke-width':0.03 });\n      add('circle', { cx:-0.1, cy:-0.1, r:0.05, fill:'rgba(255,255,255,0.25)' });\n    } else if (p.kind === 'role') {\n      add('rect', { x:-0.5, y:-0.25, width:1.0, height:0.5, rx:0.12, fill:'rgba(12,16,22,0.75)', stroke:'rgba(255,255,255,0.2)', 'stroke-width':0.04 });\n      add('rect', { x:-0.32, y:-0.08, width:0.64, height:0.16, rx:0.06, fill:'rgba(255,255,255,0.12)' });\n      add('circle', { cx:-0.22, cy:0.08, r:0.04, fill:'rgba(255,255,255,0.35)' });\n      add('circle', { cx:0.0, cy:0.08, r:0.04, fill:'rgba(255,255,255,0.35)' });\n      add('circle', { cx:0.22, cy:0.08, r:0.04, fill:'rgba(255,255,255,0.35)' });\n    } else if (p.kind === 'cone') {\n      const color = p.color || '#f97316';\n      add('polygon', { points:'0,-0.35 0.38,0.28 -0.38,0.28', fill: color, stroke:'rgba(0,0,0,0.25)', 'stroke-width':0.03 });\n      add('rect', { x:-0.35, y:0.22, width:0.7, height:0.12, rx:0.04, fill:'rgba(0,0,0,0.25)' });\n    } else if (p.kind === 'ball') {\n      add('circle', { cx:0, cy:0, r:0.28, fill:'#f7f1e5', stroke:'rgba(0,0,0,0.25)', 'stroke-width':0.03 });\n      add('circle', { cx:-0.12, cy:-0.12, r:0.08, fill:'rgba(255,255,255,0.5)' });\n      const seams = [\n        'M -0.2 -0.1 C -0.05 -0.22 0.1 -0.2 0.2 -0.06',\n        'M -0.2 0.12 C -0.04 0.0 0.12 0.0 0.2 0.14',\n        'M -0.06 -0.24 C 0.04 -0.1 0.04 0.1 -0.04 0.24',\n      ];\n      for (const d of seams) {\n        add('path', { d, fill:'none', stroke:'#d9c7a7', 'stroke-width':0.035, 'stroke-linecap':'round' });\n      }\n    } else if (p.kind === 'ball-cart') {\n      add('rect', { x:-0.55, y:-0.15, width:1.1, height:0.45, rx:0.1, fill:'rgba(18,22,30,0.9)', stroke:'rgba(255,255,255,0.25)', 'stroke-width':0.04 });\n      add('line', { x1:-0.45, y1:-0.2, x2:-0.15, y2:-0.45, stroke:'rgba(255,255,255,0.35)', 'stroke-width':0.05 });\n      add('line', { x1:0.45, y1:-0.2, x2:0.15, y2:-0.45, stroke:'rgba(255,255,255,0.35)', 'stroke-width':0.05 });\n      add('circle', { cx:-0.25, cy:0.35, r:0.08, fill:'rgba(255,255,255,0.7)' });\n      add('circle', { cx:0.25, cy:0.35, r:0.08, fill:'rgba(255,255,255,0.7)' });\n      add('circle', { cx:-0.2, cy:0.02, r:0.12, fill:'rgba(255,255,255,0.95)' });\n      add('circle', { cx:0.05, cy:-0.02, r:0.12, fill:'rgba(255,255,255,0.95)' });\n      add('circle', { cx:0.25, cy:0.06, r:0.12, fill:'rgba(255,255,255,0.95)' });\n    } else if (p.kind === 'basket') {\n      add('line', { x1:0.1, y1:-0.85, x2:0.1, y2:0.55, stroke:'rgba(255,255,255,0.6)', 'stroke-width':0.08 });\n      add('line', { x1:-0.35, y1:-0.75, x2:0.1, y2:-0.75, stroke:'rgba(255,255,255,0.6)', 'stroke-width':0.08 });\n      add('rect', { x:-0.4, y:-0.74, width:0.1, height:0.05, rx:0.02, fill:'rgba(255,255,255,0.7)' });\n      add('path', { d:'M -0.35 -0.7 L -0.2 0.1 L 0.05 0.1 L -0.1 -0.7 Z', fill:'rgba(255,255,255,0.15)', stroke:'rgba(255,255,255,0.35)', 'stroke-width':0.03 });\n      add('rect', { x:-0.55, y:0.55, width:1.1, height:0.15, rx:0.04, fill:'rgba(255,255,255,0.45)' });\n    } else if (p.kind === 'coach') {\n      add('circle', { cx:0, cy:-0.2, r:0.16, fill:'rgba(255,255,255,0.9)' });\n      add('rect', { x:-0.22, y:-0.05, width:0.44, height:0.4, rx:0.12, fill:'rgba(94,234,212,0.9)' });\n      add('rect', { x:-0.08, y:0.04, width:0.16, height:0.26, rx:0.03, fill:'rgba(255,255,255,0.95)' });\n      add('rect', { x:-0.16, y:0.04, width:0.32, height:0.06, rx:0.03, fill:'rgba(255,255,255,0.95)' });\n    } else if (p.kind === 'ladder') {\n      add('rect', { x:-0.2, y:-1.1, width:0.4, height:2.2, rx:0.06, fill:'rgba(255,255,255,0.12)', stroke:'rgba(255,255,255,0.45)', 'stroke-width':0.05 });\n      add('line', { x1:-0.16, y1:-0.8, x2:0.16, y2:-0.8, stroke:'rgba(255,255,255,0.45)', 'stroke-width':0.05 });\n      add('line', { x1:-0.16, y1:-0.45, x2:0.16, y2:-0.45, stroke:'rgba(255,255,255,0.45)', 'stroke-width':0.05 });\n      add('line', { x1:-0.16, y1:-0.1, x2:0.16, y2:-0.1, stroke:'rgba(255,255,255,0.45)', 'stroke-width':0.05 });\n      add('line', { x1:-0.16, y1:0.25, x2:0.16, y2:0.25, stroke:'rgba(255,255,255,0.45)', 'stroke-width':0.05 });\n      add('line', { x1:-0.16, y1:0.6, x2:0.16, y2:0.6, stroke:'rgba(255,255,255,0.45)', 'stroke-width':0.05 });\n    } else if (p.kind === 'target') {\n      add('circle', { cx:0, cy:0, r:0.28, fill:'none', stroke:'rgba(255,255,255,0.4)', 'stroke-width':0.04 });\n      add('circle', { cx:0, cy:0, r:0.14, fill:'rgba(255,255,255,0.2)' });\n    }\n  }\n\n  function renderProps() {\n    gProps.innerHTML = '';\n    const angle = ((state.rotation % 360) + 360) % 360;\n    for (const p of state.props) {\n      const g = document.createElementNS(svgNS, 'g');\n      g.setAttribute('data-id', p.id);\n      const rot = p.rotation || 0;\n      const scale = p.scale || 1;\n      g.setAttribute('transform', `translate(${p.x} ${p.y}) rotate(${rot}) scale(${scale})`);\n      g.style.cursor = 'grab';\n      const gInner = document.createElementNS(svgNS, 'g');\n      const counter = -(angle);\n      if (angle || rot) gInner.setAttribute('transform', `rotate(${counter + rot})`);\n      drawPropShape(gInner, p);\n\n      if (isSelected(p.id)) {\n        const sel = document.createElementNS(svgNS, 'circle');\n        sel.setAttribute('cx', '0');\n        sel.setAttribute('cy', '0');\n        sel.setAttribute('r', '0.6');\n        sel.setAttribute('fill', 'none');\n        sel.setAttribute('stroke', 'rgba(255,255,255,0.6)');\n        sel.setAttribute('stroke-width', '0.05');\n        gInner.appendChild(sel);\n      }\n\n      g.appendChild(gInner);\n      gProps.appendChild(g);\n    }\n  }\n\n  function renderDrawings() {\n    gDrawings.innerHTML = '';\n    for (const d of state.drawings) {\n      const p = document.createElementNS(svgNS, 'path');\n      p.setAttribute('data-id', d.id);\n      p.setAttribute('d', d.path);\n      p.setAttribute('fill', 'none');\n      p.setAttribute('stroke', 'currentColor');\n      p.setAttribute('stroke-width', d.style?.width ?? '0.12');\n      p.setAttribute('stroke-linecap', 'round');\n      p.setAttribute('stroke-linejoin', 'round');\n      p.setAttribute('marker-end', 'url(#arrowHead)');\n      p.style.color = teamColor(d.team);\n      p.style.cursor = 'pointer';\n      p.setAttribute('opacity', d.style?.opacity ?? '0.9');\n\n      if (isSelected(d.id)) {\n        p.setAttribute('stroke-width', '0.18');\n        p.setAttribute('opacity', '1');\n      }\n\n      gDrawings.appendChild(p);\n      const rot = d.rotation || 0;\n      const scale = d.scale || 1;\n      if (rot !== 0 || scale !== 1) {\n        const box = p.getBBox();\n        const cx = box.x + box.width / 2;\n        const cy = box.y + box.height / 2;\n        p.setAttribute('transform', `translate(${cx} ${cy}) rotate(${rot}) scale(${scale}) translate(${-cx} ${-cy})`);\n      }\n    }\n  }\n\n  function renderTexts() {\n    gText.innerHTML = '';\n    const angle = ((state.rotation % 360) + 360) % 360;\n    for (const t of state.texts) {\n      const g = document.createElementNS(svgNS, 'g');\n      g.setAttribute('data-id', t.id);\n      const rot = t.rotation || 0;\n      const scale = t.scale || 1;\n      g.setAttribute('transform', `translate(${t.x} ${t.y}) rotate(${rot}) scale(${scale})`);\n      g.style.cursor = 'grab';\n\n      const el = document.createElementNS(svgNS, 'text');\n      el.setAttribute('x', '0');\n      el.setAttribute('y', '0');\n      el.setAttribute('font-size', t.style?.size ?? '0.55');\n      el.setAttribute('fill', 'currentColor');\n      el.style.color = teamColor(t.team);\n      if (angle || rot) el.setAttribute('transform', `rotate(${-(angle) + rot})`);\n      el.textContent = t.text;\n\n      if (isSelected(t.id)) {\n        const bb = document.createElementNS(svgNS, 'rect');\n        g.appendChild(el);\n        const box = el.getBBox();\n        bb.setAttribute('x', box.x - 0.2);\n        bb.setAttribute('y', box.y - 0.2);\n        bb.setAttribute('width', box.width + 0.4);\n        bb.setAttribute('height', box.height + 0.4);\n        bb.setAttribute('fill', 'none');\n        bb.setAttribute('stroke', 'rgba(255,255,255,0.55)');\n        bb.setAttribute('stroke-width', '0.06');\n        bb.style.pointerEvents = 'none';\n        g.insertBefore(bb, el);\n      } else {\n        g.appendChild(el);\n      }\n      gText.appendChild(g);\n    }\n  }\n\n  function elementBBoxInSvg(el) {\n    const rect = el.getBoundingClientRect();\n    const p1 = svgPointFromClient(rect.left, rect.top);\n    const p2 = svgPointFromClient(rect.right, rect.bottom);\n    const x = Math.min(p1.x, p2.x);\n    const y = Math.min(p1.y, p2.y);\n    const w = Math.abs(p2.x - p1.x);\n    const h = Math.abs(p2.y - p1.y);\n    return { x, y, w, h };\n  }\n\n  function selectionBounds(ids) {\n    let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;\n    let found = false;\n    for (const id of ids) {\n      const el = svg.querySelector(`[data-id=\"${id}\"]`);\n      if (!el) continue;\n      const box = elementBBoxInSvg(el);\n      if (!Number.isFinite(box.x)) continue;\n      found = true;\n      minX = Math.min(minX, box.x);\n      minY = Math.min(minY, box.y);\n      maxX = Math.max(maxX, box.x + box.w);\n      maxY = Math.max(maxY, box.y + box.h);\n    }\n    if (!found) return null;\n    return { x: minX, y: minY, w: maxX - minX, h: maxY - minY };\n  }\n\n  function updateSelectionRect(rectEl, start, cur) {\n    const x = Math.min(start.x, cur.x);\n    const y = Math.min(start.y, cur.y);\n    const w = Math.abs(cur.x - start.x);\n    const h = Math.abs(cur.y - start.y);\n    rectEl.setAttribute('x', String(x));\n    rectEl.setAttribute('y', String(y));\n    rectEl.setAttribute('width', String(w));\n    rectEl.setAttribute('height', String(h));\n    return { x, y, w, h };\n  }\n\n  function idsInRect(rect) {\n    const ids = [];\n    const elements = svg.querySelectorAll('[data-id]');\n    elements.forEach((el) => {\n      const id = el.getAttribute('data-id');\n      if (!id) return;\n      const box = elementBBoxInSvg(el);\n      const intersects = !(\n        box.x > rect.x + rect.w ||\n        box.x + box.w < rect.x ||\n        box.y > rect.y + rect.h ||\n        box.y + box.h < rect.y\n      );\n      if (intersects) ids.push(id);\n    });\n    return ids;\n  }\n\n  function renderHandles() {\n    gHandles.innerHTML = '';\n    const selIds = getSelection();\n    if (!selIds.length) return;\n    if (selIds.length === 1) {\n      const id = selIds[0];\n      const el = svg.querySelector(`[data-id=\"${id}\"]`);\n      if (!el) return;\n      const box = elementBBoxInSvg(el);\n      const cx = box.x + box.w / 2;\n      const cy = box.y + box.h / 2;\n      const handle = (x, y, type) => {\n        const c = document.createElementNS(svgNS, 'circle');\n        c.setAttribute('cx', String(x));\n        c.setAttribute('cy', String(y));\n        c.setAttribute('r', '0.12');\n        c.setAttribute('fill', 'rgba(17,20,26,0.9)');\n        c.setAttribute('stroke', 'rgba(255,255,255,0.7)');\n        c.setAttribute('stroke-width', '0.04');\n        c.setAttribute('data-handle', type);\n        c.setAttribute('data-target', id);\n        c.style.cursor = type === 'rotate' ? 'crosshair' : 'nwse-resize';\n        gHandles.appendChild(c);\n      };\n      handle(box.x, box.y, 'scale');\n      handle(box.x + box.w, box.y, 'scale');\n      handle(box.x, box.y + box.h, 'scale');\n      handle(box.x + box.w, box.y + box.h, 'scale');\n      handle(cx, box.y - 0.4, 'rotate');\n      return;\n    }\n\n    const box = selectionBounds(selIds);\n    if (!box) return;\n    const rect = document.createElementNS(svgNS, 'rect');\n    rect.setAttribute('x', String(box.x));\n    rect.setAttribute('y', String(box.y));\n    rect.setAttribute('width', String(box.w));\n    rect.setAttribute('height', String(box.h));\n    rect.setAttribute('fill', 'none');\n    rect.setAttribute('stroke', 'rgba(255,255,255,0.55)');\n    rect.setAttribute('stroke-width', '0.05');\n    rect.setAttribute('stroke-dasharray', '0.18 0.12');\n    rect.style.pointerEvents = 'none';\n    gHandles.appendChild(rect);\n\n    const cx = box.x + box.w / 2;\n    const cy = box.y + box.h / 2;\n    const handle = (x, y, type) => {\n      const c = document.createElementNS(svgNS, 'circle');\n      c.setAttribute('cx', String(x));\n      c.setAttribute('cy', String(y));\n      c.setAttribute('r', '0.12');\n      c.setAttribute('fill', 'rgba(17,20,26,0.9)');\n      c.setAttribute('stroke', 'rgba(255,255,255,0.7)');\n      c.setAttribute('stroke-width', '0.04');\n      c.setAttribute('data-handle', type);\n      c.setAttribute('data-target', '__group__');\n      c.style.cursor = type === 'rotate' ? 'crosshair' : 'nwse-resize';\n      gHandles.appendChild(c);\n    };\n    handle(box.x, box.y, 'scale');\n    handle(box.x + box.w, box.y, 'scale');\n    handle(box.x, box.y + box.h, 'scale');\n    handle(box.x + box.w, box.y + box.h, 'scale');\n    handle(cx, box.y - 0.4, 'rotate');\n  }\n\n  function renderInspector() {\n    if (inspectorOverlay) inspectorOverlay.style.display = 'none';\n    inspector.innerHTML = '';\n    const selIds = getSelection();\n    if (!selIds.length) {\n      inspector.innerHTML = `<div class=\"muted\">Nessuna selezione</div>`;\n      return;\n    }\n    if (selIds.length > 1) {\n      inspector.innerHTML = `<div class=\"muted\">${selIds.length} elementi selezionati</div>`;\n      const del = document.createElement('button');\n      del.className = 'btn btnDanger';\n      del.textContent = 'Elimina selezionati';\n      del.type = 'button';\n      del.addEventListener('click', () => { removeSelected(); });\n      inspector.appendChild(del);\n      return;\n    }\n\n    const sel = objById(selIds[0]);\n    if (!sel) {\n      inspector.innerHTML = `<div class=\"muted\">Nessuna selezione</div>`;\n      return;\n    }\n\n    const row = (label, inputEl) => {\n      const r = document.createElement('div');\n      r.className = 'row';\n      const l = document.createElement('div');\n      l.className = 'label';\n      l.textContent = label;\n      const w = document.createElement('div');\n      w.appendChild(inputEl);\n      r.appendChild(l);\n      r.appendChild(w);\n      inspector.appendChild(r);\n    };\n\n    const type = sel.type || (sel.id === 'ball' ? 'ball' : 'unknown');\n    const typeEl = document.createElement('div');\n    typeEl.className = 'muted';\n    typeEl.textContent = `Tipo: ${type}`;\n    inspector.appendChild(typeEl);\n\n    if (type === 'player') {\n      const overrideInput = document.createElement('input');\n      overrideInput.value = sel.overrideText || '';\n      overrideInput.addEventListener('input', () => { sel.overrideText = overrideInput.value; commit(); });\n      row('Testo speciale', overrideInput);\n\n      const labelInput = document.createElement('input');\n      labelInput.value = sel.label || '';\n      labelInput.addEventListener('input', () => { sel.label = labelInput.value; commit(); });\n      row('Numero', labelInput);\n\n      const roleSel = document.createElement('select');\n      for (const r of ROLES) {\n        const opt = document.createElement('option');\n        opt.value = r.id;\n        opt.textContent = r.name;\n        roleSel.appendChild(opt);\n      }\n      roleSel.value = sel.role || 'X';\n      roleSel.addEventListener('change', () => { sel.role = roleSel.value; commit(); });\n      row('Ruolo', roleSel);\n\n      const teamSel = document.createElement('select');\n      for (const t of TEAMS) {\n        const opt = document.createElement('option');\n        opt.value = t.id;\n        opt.textContent = t.name;\n        teamSel.appendChild(opt);\n      }\n      teamSel.value = sel.team || 'A';\n      teamSel.addEventListener('change', () => { sel.team = teamSel.value; commit(); });\n      row('Squadra', teamSel);\n\n      const del = document.createElement('button');\n      del.className = 'btn btnDanger';\n      del.textContent = 'Elimina';\n      del.type = 'button';\n      del.addEventListener('click', () => { removeSelected(); });\n      inspector.appendChild(del);\n    }\n\n    if (type === 'arrow') {\n      const teamSel = document.createElement('select');\n      for (const t of TEAMS) {\n        const opt = document.createElement('option');\n        opt.value = t.id;\n        opt.textContent = t.name;\n        teamSel.appendChild(opt);\n      }\n      teamSel.value = sel.team || 'A';\n      teamSel.addEventListener('change', () => { sel.team = teamSel.value; commit(); });\n      row('Squadra', teamSel);\n\n      const opacity = document.createElement('input');\n      opacity.type = 'number';\n      opacity.min = '0.1';\n      opacity.max = '1';\n      opacity.step = '0.1';\n      opacity.value = sel.style?.opacity ?? 0.9;\n      opacity.addEventListener('input', () => {\n        sel.style = sel.style || {};\n        sel.style.opacity = String(clamp(Number(opacity.value)||0.9, 0.1, 1));\n        commit();\n      });\n      row('Opacità', opacity);\n\n      const del = document.createElement('button');\n      del.className = 'btn btnDanger';\n      del.textContent = 'Elimina';\n      del.type = 'button';\n      del.addEventListener('click', () => { removeSelected(); });\n      inspector.appendChild(del);\n    }\n\n    if (type === 'text') {\n      const txt = document.createElement('input');\n      txt.value = sel.text || '';\n      txt.addEventListener('input', () => { sel.text = txt.value; commit(); });\n      row('Testo', txt);\n\n      const size = document.createElement('input');\n      size.type = 'number';\n      size.min = '0.2';\n      size.max = '1.2';\n      size.step = '0.05';\n      size.value = sel.style?.size ?? 0.55;\n      size.addEventListener('input', () => {\n        sel.style = sel.style || {};\n        sel.style.size = String(clamp(Number(size.value)||0.55, 0.2, 1.2));\n        commit();\n      });\n      row('Dimensione', size);\n\n      const teamSel = document.createElement('select');\n      for (const t of TEAMS) {\n        const opt = document.createElement('option');\n        opt.value = t.id;\n        opt.textContent = t.name;\n        teamSel.appendChild(opt);\n      }\n      teamSel.value = sel.team || 'A';\n      teamSel.addEventListener('change', () => { sel.team = teamSel.value; commit(); });\n      row('Squadra', teamSel);\n\n      const del = document.createElement('button');\n      del.className = 'btn btnDanger';\n      del.textContent = 'Elimina';\n      del.type = 'button';\n      del.addEventListener('click', () => { removeSelected(); });\n      inspector.appendChild(del);\n    }\n\n    if (type === 'ball') {\n      const vis = document.createElement('button');\n      vis.className = 'btn';\n      vis.textContent = state.ball.visible ? 'Nascondi palla' : 'Mostra palla';\n      vis.type = 'button';\n      vis.addEventListener('click', () => { state.ball.visible = !state.ball.visible; commit(); });\n      inspector.appendChild(vis);\n    }\n  }\n\n  function renderStats() {\n    statObjects.textContent = String(state.objects.length + state.drawings.length + state.texts.length + state.props.length);\n  }\n\n  function render() {\n    notesEl.value = state.notes || '';\n    applyLayoutTransform();\n    applyLayerVisibility();\n    setViewBox(state.view);\n    updateLayoutTabs();\n    renderCourtSelectionHint();\n    renderDrawings();\n    renderProps();\n    renderPlayers();\n    renderTexts();\n    renderHandles();\n    renderInspector();\n    renderStats();\n  }\n\n  function renderCourtSelectionHint() {\n    // mode chip\n    const m = state.mode || MODE.SELECT;\n    const label = m === MODE.SELECT ? 'Selezione' : (m === MODE.ARROW ? 'Frecce' : (m === MODE.TEXT ? 'Testo' : 'Pan'));\n    chipMode.textContent = `Modalità: ${label}`;\n  }\n\n  function commit() {\n    syncLayoutState();\n    pushHistory(state);\n    render();\n    emitChange();\n  }\n\n  function migrateLegacyBall() {\n    const lsMap = state.layoutStates || {};\n    for (const key of Object.keys(lsMap)) {\n      const ls = lsMap[key];\n      if (!ls || !ls.ball) continue;\n      const hasPropBall = Array.isArray(ls.props) && ls.props.some(p => p.kind === 'ball');\n      if (ls.ball.visible && !hasPropBall) {\n        ls.props = Array.isArray(ls.props) ? ls.props : [];\n        ls.props.push({ id: ID(), type:'prop', kind:'ball', x: ls.ball.x ?? 9, y: ls.ball.y ?? 4.5 });\n      }\n      ls.ball.visible = false;\n    }\n    state.props = lsMap[state.layout]?.props || state.props;\n    // legacy ball no longer used\n  }\n\n  function replaceState(next) {\n    state = next;\n    if (!state.layout) state.layout = 'full-h';\n    if (!state.rotation && state.rotation !== 0) state.rotation = 0;\n    if (!LAYOUTS[state.layout]) state.layout = 'full-h';\n    if (!state.layers) state.layers = { players:true, drawings:true, text:true };\n    if (!state.mode) state.mode = MODE.SELECT;\n    state.selection = normalizeSelection(state.selection);\n    if (!state.layoutStates) {\n      state.layoutStates = {};\n      state.layoutStates[state.layout] = {\n        view: state.view || { ...(LAYOUTS[state.layout]?.view || LAYOUTS['full-h'].view) },\n        rotation: typeof state.rotation === 'number' ? state.rotation : defaultRotationFor(state.layout),\n        notes: state.notes || '',\n        objects: state.objects || [],\n        drawings: state.drawings || [],\n        texts: state.texts || [],\n        props: state.props || [],\n        selection: normalizeSelection(state.selection),\n      };\n    }\n    for (const id of Object.keys(LAYOUTS)) ensureLayoutState(id);\n    for (const id of Object.keys(state.layoutStates)) {\n      state.layoutStates[id].selection = normalizeSelection(state.layoutStates[id].selection);\n    }\n    bindLayoutState(state.layout);\n    migrateLegacyBall();\n    pushHistory(state);\n    render();\n  }\n\n  // Object creation\n  function addPlayer(team='A', x= team==='A' ? 4 : 14, y=4.5, label='', role='X') {\n    const bounds = currentCourtBounds();\n    const clampedX = clamp(x, bounds.minX ?? 0, bounds.maxX);\n    const clampedY = clamp(y, bounds.minY ?? 0, bounds.maxY);\n    state.objects.push({ id: ID(), type:'player', team, x: clampedX, y: clampedY, role, label });\n    commit();\n  }\n\n  function toggleBall() {\n    const idx = state.props.findIndex(p => p.kind === 'ball');\n    if (idx >= 0) {\n      state.props.splice(idx, 1);\n      state.selection = [];\n      commit();\n      return;\n    }\n    const bounds = currentCourtBounds();\n    const x = clamp(9, 0, bounds.maxX);\n    const y = clamp(4.5, 0, bounds.maxY);\n    addProp('ball', x, y);\n  }\n\n  function addTextAt(x,y, text='Testo', team='A') {\n    state.texts.push({ id: ID(), type:'text', x, y, text, team, style:{ size:'0.55' } });\n    commit();\n  }\n\n  function removeSelected() {\n    const ids = getSelection();\n    if (!ids.length) return;\n    state.objects = state.objects.filter(o => !ids.includes(o.id));\n    state.drawings = state.drawings.filter(d => !ids.includes(d.id));\n    state.texts = state.texts.filter(t => !ids.includes(t.id));\n    state.props = state.props.filter(p => !ids.includes(p.id));\n    state.selection = [];\n    commit();\n  }\n\n  function addProp(kind, x, y, opts = {}) {\n    const bounds = currentCourtBounds();\n    const clampedX = clamp(x, bounds.minX ?? 0, bounds.maxX);\n    const clampedY = clamp(y, bounds.minY ?? 0, bounds.maxY);\n    state.props.push({ id: ID(), type:'prop', kind, x: clampedX, y: clampedY, role: opts.role, color: opts.color });\n    commit();\n  }\n\n  function addPlayerFromTool(role, x, y) {\n    const sel = primarySelection() ? objById(primarySelection()) : null;\n    const team = (sel && sel.team) ? sel.team : 'A';\n    addPlayer(team, x, y, '', role || 'X');\n  }\n\n  function renderToolbox() {\n    if (!toolGrid) return;\n    toolGrid.innerHTML = '';\n    const iconFor = (item) => {\n      if (item.kind === 'role') return item.role || 'R';\n      if (item.kind === 'ball-cart') return 'CP';\n      if (item.kind === 'basket') return 'CAN';\n      if (item.kind === 'coach') return 'ALL';\n      if (item.kind === 'assistant') return 'ASS';\n      if (item.kind === 'ladder') return 'SCL';\n      if (item.kind === 'target') return 'BRG';\n      return item.label.slice(0, 2).toUpperCase();\n    };\n\n    for (const item of TOOLBOX_ITEMS) {\n      const b = document.createElement('button');\n      b.type = 'button';\n      b.className = 'toolBtn';\n      b.setAttribute('draggable', 'true');\n      b.dataset.kind = item.kind;\n      if (item.role) b.dataset.role = item.role;\n      if (item.color) b.dataset.color = item.color;\n\n      const preview = document.createElementNS(svgNS, 'svg');\n      preview.setAttribute('class', 'toolPreview');\n      preview.setAttribute('viewBox', '-1 -1 2 2');\n      const g = document.createElementNS(svgNS, 'g');\n      const p = { kind: item.kind, role: item.role, color: item.color };\n      const scale = item.previewScale ?? 1.1;\n      g.setAttribute('transform', `scale(${scale})`);\n      drawPropShape(g, p);\n      preview.appendChild(g);\n\n      const label = document.createElement('span');\n      label.className = 'toolLabel';\n      label.textContent = item.label;\n\n      b.appendChild(preview);\n      b.appendChild(label);\n\n      b.addEventListener('click', () => {\n        const v = state.view;\n        const cx = v.x + v.w / 2;\n        const cy = v.y + v.h / 2;\n        if (item.kind === 'player') {\n          addPlayerFromTool(item.role, cx, cy);\n        } else {\n          addProp(item.kind, cx, cy, { role: item.role, color: item.color });\n        }\n      });\n\n      b.addEventListener('dragstart', (e) => {\n        e.dataTransfer.effectAllowed = 'copy';\n        e.dataTransfer.setData('application/json', JSON.stringify({\n          kind: item.kind,\n          role: item.role || '',\n          color: item.color || '',\n        }));\n      });\n\n      toolGrid.appendChild(b);\n    }\n  }\n\n  // Presets\n  function presetEmpty() {\n    state.objects = [];\n    state.drawings = [];\n    state.texts = [];\n    state.props = [];\n    state.selection = [];\n    commit();\n  }\n\n  const DEFAULT_SPOTS_A = [\n    {x: 2.0, y: 7.8, n:'1'},\n    {x: 2.0, y: 4.5, n:'6'},\n    {x: 2.0, y: 1.2, n:'5'},\n    {x: 6.0, y: 1.2, n:'4'},\n    {x: 6.0, y: 4.5, n:'3'},\n    {x: 6.0, y: 7.8, n:'2'},\n  ];\n  const DEFAULT_SPOTS = {\n    A: DEFAULT_SPOTS_A,\n    B: DEFAULT_SPOTS_A.map((p) => ({ x: COURT_W - p.x, y: COURT_H - p.y, n: p.n })),\n  };\n\n  const DEFAULT_ROLE_BY_LABEL = {\n    '1': 'P',\n    '2': 'S1',\n    '3': 'C2',\n    '4': 'O',\n    '5': 'S2',\n    '6': 'C1',\n  };\n\n  function insertDefaultTeams(mode) {\n    presetEmpty();\n    const addTeam = (team) => {\n      for (const p of DEFAULT_SPOTS[team]) {\n        const role = DEFAULT_ROLE_BY_LABEL[p.n] || 'X';\n        state.objects.push({ id: ID(), type:'player', team, x:p.x, y:p.y, role, label:'' });\n      }\n    };\n    if (mode === 'A' || mode === 'both') addTeam('A');\n    if (mode === 'B' || mode === 'both') addTeam('B');\n    state.ball = { id:'ball', x:9, y:4.5, visible:false };\n    commit();\n  }\n\n  function rotateTeam(team, dir = 'cw') {\n    const spots = DEFAULT_SPOTS[team];\n    if (!spots) return;\n    const players = state.objects.filter(o => o.type==='player' && o.team===team);\n    if (players.length === 0) return;\n\n    const orderCW = ['1','6','5','4','3','2'];\n    const order = dir === 'ccw' ? [...orderCW].reverse() : orderCW;\n    const spotByLab = new Map(spots.map((s) => [s.n, s]));\n\n    const closest = (p) => {\n      let best = null, bestD = Infinity;\n      for (const s of spots) {\n        const dx = p.x - s.x, dy = p.y - s.y;\n        const d = dx*dx + dy*dy;\n        if (d < bestD) { bestD = d; best = s; }\n      }\n      return best;\n    };\n\n    const playerByLab = new Map();\n    for (const p of players) {\n      const s = closest(p);\n      if (s) playerByLab.set(s.n, p);\n    }\n\n    for (let i = 0; i < order.length; i++) {\n      const curLab = order[i];\n      const nextLab = order[(i + 1) % order.length];\n      const p = playerByLab.get(curLab);\n      const nextSpot = spotByLab.get(nextLab);\n      if (!p || !nextSpot) continue;\n      p.x = nextSpot.x;\n      p.y = nextSpot.y;\n    }\n\n    commit();\n  }\n\n  // Modes and actions\n  state.mode = MODE.SELECT;\n\n  function setMode(m) {\n    state.mode = m;\n    render();\n  }\n\n  // Toolbar buttons\n  $('#btnAddPlayer').addEventListener('click', () => {\n    // Add to the side closer to current selection/team if possible\n    const sel = primarySelection() ? objById(primarySelection()) : null;\n    const team = (sel && sel.team) ? sel.team : 'A';\n    const bounds = currentCourtBounds();\n    const baseX = team === 'A' ? 4 : 14;\n    const x = clamp(baseX, 0, bounds.maxX);\n    const y = clamp(4.5, 0, bounds.maxY);\n    addPlayer(team, x, y, '', 'X');\n  });\n\n\n  $('#btnArrow').addEventListener('click', () => {\n    setMode(state.mode === MODE.ARROW ? MODE.SELECT : MODE.ARROW);\n  });\n\n  $('#btnText').addEventListener('click', () => {\n    setMode(state.mode === MODE.TEXT ? MODE.SELECT : MODE.TEXT);\n  });\n\n  $('#btnRotateACW').addEventListener('click', () => rotateTeam('A', 'cw'));\n  $('#btnRotateACCW').addEventListener('click', () => rotateTeam('A', 'ccw'));\n  $('#btnRotateBCW').addEventListener('click', () => rotateTeam('B', 'cw'));\n  $('#btnRotateBCCW').addEventListener('click', () => rotateTeam('B', 'ccw'));\n  $('#btnUndo').addEventListener('click', () => { const s = undo(); if (s) replaceState(s); });\n  $('#btnRedo').addEventListener('click', () => { const s = redo(); if (s) replaceState(s); });\n\n  $('#btnReset').addEventListener('click', () => { replaceState(DEFAULT_STATE()); });\n\n  function exportFilename(ext) {\n    const d = new Date();\n    const pad = (n) => String(n).padStart(2, '0');\n    const stamp = `${d.getFullYear()}${pad(d.getMonth()+1)}${pad(d.getDate())}_${pad(d.getHours())}${pad(d.getMinutes())}`;\n    return `volleyboard_${state.layout}_${stamp}.${ext}`;\n  }\n\n  function downloadBlob(blob, filename) {\n    const url = URL.createObjectURL(blob);\n    const a = document.createElement('a');\n    a.href = url;\n    a.download = filename;\n    document.body.appendChild(a);\n    a.click();\n    a.remove();\n    setTimeout(() => URL.revokeObjectURL(url), 1000);\n  }\n\n  function exportViewBox() {\n    return { ...getBaseView() };\n  }\n\n  function buildExportSvg(width, height, viewBox) {\n    const clone = svg.cloneNode(true);\n    const handles = clone.querySelector('#handles');\n    if (handles) handles.remove();\n    let defsEl = clone.querySelector('defs');\n    if (!defsEl) {\n      defsEl = document.createElementNS(svgNS, 'defs');\n      clone.insertBefore(defsEl, clone.firstChild);\n    }\n    if (!defsEl.querySelector('#exportBg')) {\n      const exportBg = document.createElementNS(svgNS, 'linearGradient');\n      exportBg.setAttribute('id', 'exportBg');\n      exportBg.setAttribute('x1', '0');\n      exportBg.setAttribute('y1', '0');\n      exportBg.setAttribute('x2', '0');\n      exportBg.setAttribute('y2', '1');\n      exportBg.innerHTML = `\n        <stop offset=\"0%\" stop-color=\"#2d9848\"></stop>\n        <stop offset=\"100%\" stop-color=\"#1f502c\"></stop>\n      `;\n      defsEl.appendChild(exportBg);\n    }\n    const bgRect = document.createElementNS(svgNS, 'rect');\n    bgRect.setAttribute('x', String(viewBox.x));\n    bgRect.setAttribute('y', String(viewBox.y));\n    bgRect.setAttribute('width', String(viewBox.w));\n    bgRect.setAttribute('height', String(viewBox.h));\n    bgRect.setAttribute('fill', 'url(#exportBg)');\n    clone.insertBefore(bgRect, clone.firstChild);\n    clone.setAttribute('xmlns', svgNS);\n    clone.setAttribute('xmlns:xlink', 'http://www.w3.org/1999/xlink');\n    clone.setAttribute('viewBox', `${viewBox.x} ${viewBox.y} ${viewBox.w} ${viewBox.h}`);\n    clone.setAttribute('width', String(width));\n    clone.setAttribute('height', String(height));\n    return new XMLSerializer().serializeToString(clone);\n  }\n\n  function getExportSize(viewBox) {\n    const baseW = Math.max(1, svg.clientWidth);\n    const scale = 2;\n    let width = Math.round(baseW * scale);\n    let height = Math.round(width * (viewBox.h / viewBox.w));\n    const maxDim = 4096;\n    if (Math.max(width, height) > maxDim) {\n      const k = maxDim / Math.max(width, height);\n      width = Math.round(width * k);\n      height = Math.round(height * k);\n    }\n    return { width, height };\n  }\n\n  async function exportPng() {\n    const prevSelection = getSelection();\n    if (prevSelection.length) {\n      state.selection = [];\n      render();\n    }\n    const vb = exportViewBox();\n    const { width, height } = getExportSize(vb);\n    const svgString = buildExportSvg(width, height, vb);\n    const svgBlob = new Blob([svgString], { type: 'image/svg+xml;charset=utf-8' });\n    const url = URL.createObjectURL(svgBlob);\n    const img = new Image();\n    img.onload = () => {\n      const canvas = document.createElement('canvas');\n      canvas.width = width;\n      canvas.height = height;\n      const ctx = canvas.getContext('2d');\n      ctx.drawImage(img, 0, 0, width, height);\n      canvas.toBlob((blob) => {\n        if (blob) downloadBlob(blob, exportFilename('png'));\n        URL.revokeObjectURL(url);\n      }, 'image/png');\n    };\n    img.onerror = () => URL.revokeObjectURL(url);\n    img.src = url;\n    if (prevSelection.length) {\n      state.selection = prevSelection;\n      render();\n    }\n  }\n\n  function exportSvgString() {\n    const prevSelection = getSelection();\n    if (prevSelection.length) {\n      state.selection = [];\n      render();\n    }\n    const vb = exportViewBox();\n    const width = 520;\n    const height = Math.round(width * (vb.h / vb.w));\n    const svgString = buildExportSvg(width, height, vb);\n    if (prevSelection.length) {\n      state.selection = prevSelection;\n      render();\n    }\n    return svgString;\n  }\n\n  function serializeState() {\n    const ls = state.layoutStates?.[state.layout] || defaultLayoutState(state.layout);\n    return {\n      version: state.version || 1,\n      meta: state.meta || { createdAt: new Date().toISOString() },\n      layout: state.layout,\n      rotation: state.rotation,\n      view: ls.view,\n      notes: ls.notes,\n      layers: state.layers,\n      objects: ls.objects,\n      drawings: ls.drawings,\n      texts: ls.texts,\n      props: ls.props,\n    };\n  }\n\n  function applySerializedState(next) {\n    if (!next || typeof next !== 'object') return;\n    if (next.layout && LAYOUTS[next.layout]) {\n      syncLayoutState();\n      state.layout = next.layout;\n      bindLayoutState(state.layout);\n      updateLayoutTabs();\n    }\n    ensureLayoutState(state.layout);\n    const ls = state.layoutStates[state.layout];\n    ls.view = next.view || { ...(LAYOUTS[state.layout]?.view || LAYOUTS['full-h'].view) };\n    ls.notes = next.notes || '';\n    ls.objects = Array.isArray(next.objects) ? next.objects : [];\n    ls.drawings = Array.isArray(next.drawings) ? next.drawings : [];\n    ls.texts = Array.isArray(next.texts) ? next.texts : [];\n    ls.props = Array.isArray(next.props) ? next.props : [];\n    if (next.ball) ls.ball = next.ball;\n    ls.selection = [];\n    bindLayoutState(state.layout);\n    if (typeof next.rotation === 'number') {\n      state.rotation = ((next.rotation % 360) + 360) % 360;\n      ls.rotation = state.rotation;\n    }\n    if (next.layers) state.layers = next.layers;\n    commit();\n  }\n\n  // Import/Export dialogs\n  const dlgIO = $('#dlgIO');\n  const dlgTitle = $('#dlgTitle');\n  const ioText = $('#ioText');\n  const btnIOMain = $('#btnIOMain');\n\n  function openExport() {\n    dlgTitle.textContent = 'Export JSON';\n    ioText.value = JSON.stringify(serializeState(), null, 2);\n    btnIOMain.textContent = 'Copia';\n    btnIOMain.onclick = async (e) => {\n      e.preventDefault();\n      try { await navigator.clipboard.writeText(ioText.value); } catch {}\n      dlgIO.close();\n    };\n    dlgIO.showModal();\n    ioText.focus();\n    ioText.select();\n  }\n\n  function openImport() {\n    dlgTitle.textContent = 'Import JSON';\n    ioText.value = '';\n    btnIOMain.textContent = 'Importa';\n    btnIOMain.onclick = (e) => {\n      e.preventDefault();\n      try {\n        const next = JSON.parse(ioText.value);\n        applySerializedState(next);\n        dlgIO.close();\n      } catch (err) {\n        alert('JSON non valido');\n      }\n    };\n    dlgIO.showModal();\n    ioText.focus();\n  }\n\n  $('#btnExport').addEventListener('click', () => openExport());\n  $('#btnImport').addEventListener('click', () => openImport());\n  $('#btnExportImg').addEventListener('click', () => exportPng());\n\n  if (zoomSlider) {\n    zoomSlider.addEventListener('input', () => {\n      const base = getBaseView();\n      const z = clamp(Number(zoomSlider.value) / 100, 0.5, 2);\n      const w = base.w / z;\n      const h = base.h / z;\n      const cx = state.view.x + state.view.w / 2;\n      const cy = state.view.y + state.view.h / 2;\n      setViewBox({ x: cx - w / 2, y: cy - h / 2, w, h });\n      state.view = { x: cx - w / 2, y: cy - h / 2, w, h };\n      commit();\n    });\n  }\n\n  // Notes binding\n  notesEl.addEventListener('input', () => { state.notes = notesEl.value; commit(); });\n\n  // Layout tabs\n  $$('.layoutTabs .tab').forEach((b) => {\n    b.addEventListener('click', () => {\n      const layoutId = b.getAttribute('data-layout');\n      if (layoutId) setLayout(layoutId);\n    });\n  });\n  $('#btnRotateLeft').addEventListener('click', () => {\n    state.rotation = (state.rotation + 270) % 360;\n    state.view = { ...getBaseView() };\n    setViewBox({ ...state.view });\n    applyLayoutTransform();\n    commit();\n  });\n  $('#btnRotateRight').addEventListener('click', () => {\n    state.rotation = (state.rotation + 90) % 360;\n    state.view = { ...getBaseView() };\n    setViewBox({ ...state.view });\n    applyLayoutTransform();\n    commit();\n  });\n\n  // Default teams + empty\n  $$('.presetGrid .btn').forEach(b => {\n    b.addEventListener('click', () => {\n      const p = b.getAttribute('data-preset');\n      if (p === 'empty') presetEmpty();\n      if (p === 'teamA') insertDefaultTeams('A');\n      if (p === 'teamB') insertDefaultTeams('B');\n      if (p === 'teams') insertDefaultTeams('both');\n    });\n  });\n\n  // Add player by role\n  const addTeamSel = $('#addTeam');\n  const addRoleSel = $('#addRole');\n  const addNumberInput = $('#addNumber');\n  const fillSelect = (sel, items, getValue) => {\n    sel.innerHTML = '';\n    for (const item of items) {\n      const opt = document.createElement('option');\n      opt.value = getValue(item);\n      opt.textContent = item.name;\n      sel.appendChild(opt);\n    }\n  };\n  fillSelect(addTeamSel, TEAMS, (t) => t.id);\n  fillSelect(addRoleSel, ROLES, (r) => r.id);\n  addTeamSel.value = 'A';\n  addRoleSel.value = 'X';\n  $('#btnAddRolePlayer').addEventListener('click', () => {\n    const team = addTeamSel.value || 'A';\n    const role = addRoleSel.value || 'X';\n    const label = (addNumberInput.value || '').trim();\n    const bounds = currentCourtBounds();\n    const baseX = team === 'A' ? 4 : 14;\n    const x = clamp(baseX, 0, bounds.maxX);\n    const y = clamp(4.5, 0, bounds.maxY);\n    addPlayer(team, x, y, label, role);\n    addNumberInput.value = '';\n  });\n\n  // Context menu dropdown\n  function closeContextMenu() {\n    if (!ctxMenu) return;\n    ctxMenu.hidden = true;\n    ctxMenu.innerHTML = '';\n  }\n\n  function openMenuForSelection(clientX, clientY) {\n    if (!ctxMenu) return;\n    const selIds = getSelection();\n    const sel = selIds.length === 1 ? objById(selIds[0]) : null;\n    ctxMenu.innerHTML = '';\n    ctxMenu.hidden = false;\n\n    const wrapRect = stage.getBoundingClientRect();\n    const left = clamp(clientX - wrapRect.left, 8, wrapRect.width - 8);\n    const top = clamp(clientY - wrapRect.top, 8, wrapRect.height - 8);\n    ctxMenu.style.left = `${left}px`;\n    ctxMenu.style.top = `${top}px`;\n\n    const title = document.createElement('div');\n    title.className = 'menuTitle';\n    title.textContent = sel ? 'Modifica' : 'Azioni';\n    ctxMenu.appendChild(title);\n\n    const row = (label, inputEl) => {\n      const r = document.createElement('div');\n      r.className = 'menuRow';\n      const l = document.createElement('div');\n      l.className = 'menuLabel';\n      l.textContent = label;\n      const w = document.createElement('div');\n      w.appendChild(inputEl);\n      r.appendChild(l);\n      r.appendChild(w);\n      ctxMenu.appendChild(r);\n    };\n\n    const actions = document.createElement('div');\n    actions.className = 'menuActions';\n    const addBtn = (label, fn, cls='btn') => {\n      const b = document.createElement('button');\n      b.className = cls;\n      b.type = 'button';\n      b.textContent = label;\n      b.addEventListener('click', () => { fn(); closeContextMenu(); });\n      actions.appendChild(b);\n    };\n\n    if (!sel && selIds.length > 1) {\n      addBtn('Elimina selezionati', () => removeSelected(), 'btn btnDanger');\n      ctxMenu.appendChild(actions);\n      return;\n    }\n\n    if (!sel) {\n      addBtn('Aggiungi giocatore A', () => addPlayer('A', 4, 4.5, ''), 'btn');\n      addBtn('Aggiungi giocatore B', () => addPlayer('B', 14, 4.5, ''), 'btn');\n      addBtn('Aggiungi testo', () => { setMode(MODE.TEXT); }, 'btn');\n      addBtn('Frecce', () => { setMode(MODE.ARROW); }, 'btn');\n      addBtn('Reset', () => replaceState(DEFAULT_STATE()), 'btn btnDanger');\n      ctxMenu.appendChild(actions);\n      return;\n    }\n\n    if (sel.type === 'player') {\n      const overrideInput = document.createElement('input');\n      overrideInput.value = sel.overrideText || '';\n      overrideInput.addEventListener('input', () => { sel.overrideText = overrideInput.value; commit(); });\n      row('Testo speciale', overrideInput);\n\n      const labelInput = document.createElement('input');\n      labelInput.value = sel.label || '';\n      labelInput.addEventListener('input', () => { sel.label = labelInput.value; commit(); });\n      row('Numero', labelInput);\n\n      const roleSel = document.createElement('select');\n      for (const r of ROLES) {\n        const opt = document.createElement('option');\n        opt.value = r.id;\n        opt.textContent = r.name;\n        roleSel.appendChild(opt);\n      }\n      roleSel.value = sel.role || 'X';\n      roleSel.addEventListener('change', () => { sel.role = roleSel.value; commit(); });\n      row('Ruolo', roleSel);\n\n      const teamSel = document.createElement('select');\n      for (const t of TEAMS) {\n        const opt = document.createElement('option');\n        opt.value = t.id;\n        opt.textContent = t.name;\n        teamSel.appendChild(opt);\n      }\n      teamSel.value = sel.team || 'A';\n      teamSel.addEventListener('change', () => { sel.team = teamSel.value; commit(); });\n      row('Squadra', teamSel);\n\n      addBtn('Duplica', () => { state.objects.push({ ...sel, id: ID(), x: sel.x+0.6, y: sel.y+0.6 }); commit(); }, 'btn');\n      addBtn('Elimina', () => removeSelected(), 'btn btnDanger');\n    } else if (sel.type === 'arrow') {\n      const teamSel = document.createElement('select');\n      for (const t of TEAMS) {\n        const opt = document.createElement('option');\n        opt.value = t.id;\n        opt.textContent = t.name;\n        teamSel.appendChild(opt);\n      }\n      teamSel.value = sel.team || 'A';\n      teamSel.addEventListener('change', () => { sel.team = teamSel.value; commit(); });\n      row('Squadra', teamSel);\n\n      const opacity = document.createElement('input');\n      opacity.type = 'number';\n      opacity.min = '0.1';\n      opacity.max = '1';\n      opacity.step = '0.1';\n      opacity.value = sel.style?.opacity ?? 0.9;\n      opacity.addEventListener('input', () => {\n        sel.style = sel.style || {};\n        sel.style.opacity = String(clamp(Number(opacity.value)||0.9, 0.1, 1));\n        commit();\n      });\n      row('Opacità', opacity);\n\n      addBtn('Elimina', () => removeSelected(), 'btn btnDanger');\n    } else if (sel.type === 'text') {\n      const txt = document.createElement('input');\n      txt.value = sel.text || '';\n      txt.addEventListener('input', () => { sel.text = txt.value; commit(); });\n      row('Testo', txt);\n\n      const size = document.createElement('input');\n      size.type = 'number';\n      size.min = '0.2';\n      size.max = '1.2';\n      size.step = '0.05';\n      size.value = sel.style?.size ?? 0.55;\n      size.addEventListener('input', () => {\n        sel.style = sel.style || {};\n        sel.style.size = String(clamp(Number(size.value)||0.55, 0.2, 1.2));\n        commit();\n      });\n      row('Dimensione', size);\n\n      const teamSel = document.createElement('select');\n      for (const t of TEAMS) {\n        const opt = document.createElement('option');\n        opt.value = t.id;\n        opt.textContent = t.name;\n        teamSel.appendChild(opt);\n      }\n      teamSel.value = sel.team || 'A';\n      teamSel.addEventListener('change', () => { sel.team = teamSel.value; commit(); });\n      row('Squadra', teamSel);\n\n      addBtn('Elimina', () => removeSelected(), 'btn btnDanger');\n    } else if (sel.type === 'prop') {\n      addBtn('Duplica', () => { state.props.push({ ...sel, id: ID(), x: sel.x+0.6, y: sel.y+0.6 }); commit(); }, 'btn');\n      addBtn('Elimina', () => removeSelected(), 'btn btnDanger');\n    }\n\n    ctxMenu.appendChild(actions);\n  }\n\n  // Interaction: pointer events for drag, arrow drawing, pan\n  let activePointerId = null;\n  let drag = null; // {id, startX,startY, objStartX,objStartY}\n  let arrowDraft = null; // {team, start, cur, pathEl}\n  let selectionBox = null;\n  const DRAG_SELECT_PX = 6;\n  let longPressTimer = null;\n  let spaceDown = false;\n  let overlayDrag = null;\n\n  window.addEventListener('keydown', (e) => {\n    if (e.code === 'Space') { spaceDown = true; setMode(MODE.PAN); }\n    if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'z') {\n      const s = undo(); if (s) replaceState(s);\n    }\n    if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'y') {\n      const s = redo(); if (s) replaceState(s);\n    }\n    if (e.key === 'Delete' || e.key === 'Backspace') {\n      if (document.activeElement && ['INPUT','TEXTAREA','SELECT'].includes(document.activeElement.tagName)) return;\n      removeSelected();\n    }\n    if (e.key === 'Escape') { setMode(MODE.SELECT); }\n  });\n\n  window.addEventListener('keyup', (e) => {\n    if (e.code === 'Space') { spaceDown = false; setMode(MODE.SELECT); }\n  });\n\n  // Draggable inspector overlay\n  inspectorHandle.addEventListener('pointerdown', (e) => {\n    if (!ENABLE_LONG_PRESS_MENU) {\n      e.preventDefault();\n      return;\n    }\n    e.preventDefault();\n    inspectorOverlay.setPointerCapture(e.pointerId);\n    const wrapRect = stage.getBoundingClientRect();\n    const rect = inspectorOverlay.getBoundingClientRect();\n    inspectorOverlay.style.right = '';\n    inspectorOverlay.style.bottom = '';\n    overlayDrag = {\n      id: e.pointerId,\n      startX: e.clientX,\n      startY: e.clientY,\n      startLeft: rect.left - wrapRect.left,\n      startTop: rect.top - wrapRect.top,\n      wrapRect,\n    };\n    inspectorOverlay.style.left = `${overlayDrag.startLeft}px`;\n    inspectorOverlay.style.top = `${overlayDrag.startTop}px`;\n  });\n\n  window.addEventListener('pointermove', (e) => {\n    if (!overlayDrag || e.pointerId !== overlayDrag.id) return;\n    const dx = e.clientX - overlayDrag.startX;\n    const dy = e.clientY - overlayDrag.startY;\n    const maxLeft = overlayDrag.wrapRect.width - inspectorOverlay.offsetWidth;\n    const maxTop = overlayDrag.wrapRect.height - inspectorOverlay.offsetHeight;\n    const left = clamp(overlayDrag.startLeft + dx, 0, Math.max(0, maxLeft));\n    const top = clamp(overlayDrag.startTop + dy, 0, Math.max(0, maxTop));\n    inspectorOverlay.style.left = `${left}px`;\n    inspectorOverlay.style.top = `${top}px`;\n  });\n\n  window.addEventListener('pointerup', (e) => {\n    if (!overlayDrag || e.pointerId !== overlayDrag.id) return;\n    inspectorOverlay.releasePointerCapture(e.pointerId);\n    overlayDrag = null;\n  });\n\n  function hitTestTarget(el) {\n    if (!el) return null;\n    const id = el.getAttribute?.('data-id') || el.closest?.('[data-id]')?.getAttribute('data-id');\n    return id || null;\n  }\n\n  function startLongPress() {\n    if (!ENABLE_LONG_PRESS_MENU) return;\n    clearTimeout(longPressTimer);\n    longPressTimer = setTimeout(() => {\n      openMenuForSelection();\n    }, 520);\n  }\n\n  function cancelLongPress() {\n    clearTimeout(longPressTimer);\n    longPressTimer = null;\n  }\n\n  gHandles.addEventListener('pointerdown', (e) => {\n    const handle = e.target?.getAttribute?.('data-handle');\n    const targetId = e.target?.getAttribute?.('data-target');\n    if (!handle || !targetId) return;\n    e.stopPropagation();\n    e.preventDefault();\n    gHandles.setPointerCapture(e.pointerId);\n    activePointerId = e.pointerId;\n    const pt = svgPointFromClient(e.clientX, e.clientY);\n    if (targetId === '__group__') {\n      const box = selectionBounds(getSelection());\n      if (!box) return;\n      const cx = box.x + box.w / 2;\n      const cy = box.y + box.h / 2;\n      const items = getTransformableSelection()\n        .map((o) => ({ id: o.id, x: o.x, y: o.y, rotation: o.rotation, scale: o.scale }));\n      if (!items.length) return;\n      if (handle === 'rotate') {\n        const startAngle = Math.atan2(pt.y - cy, pt.x - cx) * 180 / Math.PI;\n        drag = { type:'rotate-group', center:{x:cx,y:cy}, startAngle, items };\n      } else if (handle === 'scale') {\n        const startDist = Math.max(0.01, Math.hypot(pt.x - cx, pt.y - cy));\n        drag = { type:'scale-group', center:{x:cx,y:cy}, startDist, items };\n      }\n      return;\n    }\n\n    const el = svg.querySelector(`[data-id=\"${targetId}\"]`);\n    if (!el) return;\n    const box = elementBBoxInSvg(el);\n    const cx = box.x + box.w / 2;\n    const cy = box.y + box.h / 2;\n    const obj = objById(targetId) || (targetId === 'ball' ? state.ball : null);\n    if (!obj) return;\n    if (handle === 'rotate') {\n      const startAngle = Math.atan2(pt.y - cy, pt.x - cx) * 180 / Math.PI;\n      drag = { type:'rotate', id: targetId, center:{x:cx,y:cy}, startAngle, startRot: obj.rotation || 0 };\n    } else if (handle === 'scale') {\n      const startDist = Math.max(0.01, Math.hypot(pt.x - cx, pt.y - cy));\n      drag = { type:'scale', id: targetId, center:{x:cx,y:cy}, startDist, startScale: obj.scale || 1 };\n    }\n  });\n\n  svg.addEventListener('pointerdown', (e) => {\n    e.preventDefault();\n    svg.focus();\n    svg.setPointerCapture(e.pointerId);\n    activePointerId = e.pointerId;\n\n    const pt = svgPointFromClient(e.clientX, e.clientY);\n    const targetId = hitTestTarget(e.target);\n    const mode = state.mode;\n\n    startLongPress();\n\n    if (spaceDown || mode === MODE.PAN) {\n      drag = { type:'pan', startClientX: e.clientX, startClientY: e.clientY, startView: { ...state.view } };\n      cancelLongPress();\n      return;\n    }\n\n    if (mode === MODE.ARROW) {\n      cancelLongPress();\n      const sel = primarySelection() ? objById(primarySelection()) : null;\n      const team = (sel && sel.team) ? sel.team : 'A';\n      arrowDraft = { team, start: pt, cur: pt };\n      // temp path\n      const pathEl = document.createElementNS(svgNS, 'path');\n      pathEl.setAttribute('d', `M ${pt.x} ${pt.y} L ${pt.x} ${pt.y}`);\n      pathEl.setAttribute('fill', 'none');\n      pathEl.setAttribute('stroke', 'currentColor');\n      pathEl.setAttribute('stroke-width', '0.12');\n      pathEl.setAttribute('stroke-linecap', 'round');\n      pathEl.setAttribute('stroke-linejoin', 'round');\n      pathEl.setAttribute('marker-end', 'url(#arrowHead)');\n      pathEl.setAttribute('opacity', '0.9');\n      pathEl.style.color = teamColor(team);\n      pathEl.style.pointerEvents = 'none';\n      gDrawings.appendChild(pathEl);\n      arrowDraft.pathEl = pathEl;\n      return;\n    }\n\n    if (mode === MODE.TEXT) {\n      cancelLongPress();\n      addTextAt(pt.x, pt.y, 'Testo', 'A');\n      setMode(MODE.SELECT);\n      return;\n    }\n\n    // select/drag objects\n    if (targetId) {\n      cancelLongPress();\n      if (e.shiftKey) {\n        toggleSelection(targetId);\n        return;\n      }\n      const selIds = getSelection();\n      const isSel = isSelected(targetId);\n      if (isSel && selIds.length > 1) {\n        const items = selIds\n          .map((id) => objById(id))\n          .filter((o) => o && (o.type === 'player' || o.type === 'text' || o.type === 'prop'));\n        if (items.some((o) => o.id === targetId)) {\n          drag = { type:'move-multi', start: pt, items: items.map((o) => ({ id: o.id, x: o.x, y: o.y })) };\n          return;\n        }\n      }\n      if (!isSel) {\n        drag = { type:'pending-select', id: targetId, start: pt, startClientX: e.clientX, startClientY: e.clientY };\n        return;\n      }\n      const obj = objById(targetId);\n      if (!obj) return;\n      // start drag\n      if (obj.type === 'player' || obj.type === 'text' || obj.type === 'prop') {\n        drag = { type:'move', id: targetId, start: pt, startObj: { x: obj.x, y: obj.y } };\n      }\n      return;\n    }\n\n    if (mode === MODE.SELECT) {\n      cancelLongPress();\n      const rect = document.createElementNS(svgNS, 'rect');\n      rect.setAttribute('fill', 'rgba(94,234,212,0.12)');\n      rect.setAttribute('stroke', 'rgba(94,234,212,0.7)');\n      rect.setAttribute('stroke-width', '0.05');\n      rect.setAttribute('stroke-dasharray', '0.18 0.12');\n      rect.style.pointerEvents = 'none';\n      gHandles.appendChild(rect);\n      selectionBox = { start: pt, rectEl: rect, additive: e.shiftKey };\n      drag = { type:'selectbox', start: pt, additive: e.shiftKey };\n      updateSelectionRect(rect, pt, pt);\n      return;\n    }\n\n    // click on empty court => clear selection\n    clearSelection();\n  });\n\n  svg.addEventListener('pointermove', (e) => {\n    if (e.pointerId !== activePointerId) return;\n    e.preventDefault();\n    const pt = svgPointFromClient(e.clientX, e.clientY);\n\n    // cancel long press if moved a bit\n    if (longPressTimer && drag) cancelLongPress();\n\n    if (drag?.type === 'rotate-group') {\n      cancelLongPress();\n      const cx = drag.center.x;\n      const cy = drag.center.y;\n      const ang = Math.atan2(pt.y - cy, pt.x - cx) * 180 / Math.PI;\n      const delta = ang - drag.startAngle;\n      const rad = delta * Math.PI / 180;\n      const cos = Math.cos(rad);\n      const sin = Math.sin(rad);\n      for (const it of drag.items) {\n        const obj = objById(it.id);\n        if (!obj) continue;\n        const dx = it.x - cx;\n        const dy = it.y - cy;\n        obj.x = cx + dx * cos - dy * sin;\n        obj.y = cy + dx * sin + dy * cos;\n        obj.rotation = (it.rotation || 0) + delta;\n      }\n      render();\n      return;\n    }\n\n    if (drag?.type === 'scale-group') {\n      cancelLongPress();\n      const cx = drag.center.x;\n      const cy = drag.center.y;\n      const dist = Math.max(0.01, Math.hypot(pt.x - cx, pt.y - cy));\n      const ratio = clamp(dist / Math.max(0.01, drag.startDist), 0.2, 4);\n      for (const it of drag.items) {\n        const obj = objById(it.id);\n        if (!obj) continue;\n        const dx = it.x - cx;\n        const dy = it.y - cy;\n        obj.x = cx + dx * ratio;\n        obj.y = cy + dy * ratio;\n        obj.scale = clamp((it.scale || 1) * ratio, 0.2, 4);\n      }\n      render();\n      return;\n    }\n\n    if (drag?.type === 'rotate' || drag?.type === 'scale') {\n      cancelLongPress();\n      const obj = objById(drag.id) || (drag.id === 'ball' ? state.ball : null);\n      if (!obj) return;\n      const cx = drag.center.x;\n      const cy = drag.center.y;\n      if (drag.type === 'rotate') {\n        const ang = Math.atan2(pt.y - cy, pt.x - cx) * 180 / Math.PI;\n        obj.rotation = (drag.startRot + (ang - drag.startAngle));\n      } else if (drag.type === 'scale') {\n        const dist = Math.max(0.01, Math.hypot(pt.x - cx, pt.y - cy));\n        const next = (dist / Math.max(0.01, drag.startDist)) * drag.startScale;\n        obj.scale = clamp(next, 0.2, 4);\n      }\n      render();\n      return;\n    }\n\n    if (drag?.type === 'pan') {\n      cancelLongPress();\n      const dx = (e.clientX - drag.startClientX) * (state.view.w / svg.clientWidth);\n      const dy = (e.clientY - drag.startClientY) * (state.view.h / svg.clientHeight);\n      setViewBox({ x: drag.startView.x - dx, y: drag.startView.y - dy, w: drag.startView.w, h: drag.startView.h });\n      state.view = { x: drag.startView.x - dx, y: drag.startView.y - dy, w: drag.startView.w, h: drag.startView.h };\n      return;\n    }\n\n    if (drag?.type === 'selectbox' && selectionBox) {\n      cancelLongPress();\n      updateSelectionRect(selectionBox.rectEl, selectionBox.start, pt);\n      return;\n    }\n\n    if (drag?.type === 'pending-select') {\n      cancelLongPress();\n      const dx = e.clientX - drag.startClientX;\n      const dy = e.clientY - drag.startClientY;\n      const dist = Math.hypot(dx, dy);\n      if (dist >= DRAG_SELECT_PX) {\n        const rect = document.createElementNS(svgNS, 'rect');\n        rect.setAttribute('fill', 'rgba(94,234,212,0.12)');\n        rect.setAttribute('stroke', 'rgba(94,234,212,0.7)');\n        rect.setAttribute('stroke-width', '0.05');\n        rect.setAttribute('stroke-dasharray', '0.18 0.12');\n        rect.style.pointerEvents = 'none';\n        gHandles.appendChild(rect);\n        selectionBox = { start: drag.start, rectEl: rect, additive: false };\n        drag = { type:'selectbox', start: drag.start, additive: false };\n        updateSelectionRect(rect, drag.start, pt);\n      }\n      return;\n    }\n\n    if (arrowDraft) {\n      arrowDraft.cur = pt;\n      const mx = (arrowDraft.start.x + pt.x) / 2;\n      const my = (arrowDraft.start.y + pt.y) / 2;\n      const d = `M ${arrowDraft.start.x} ${arrowDraft.start.y} Q ${mx} ${my} ${pt.x} ${pt.y}`;\n      arrowDraft.pathEl.setAttribute('d', d);\n      return;\n    }\n\n    if (drag?.type === 'move-multi') {\n      cancelLongPress();\n      const dx = pt.x - drag.start.x;\n      const dy = pt.y - drag.start.y;\n      const bounds = currentCourtBounds();\n      for (const it of drag.items) {\n        const obj = objById(it.id);\n        if (!obj) continue;\n        obj.x = clamp(it.x + dx, bounds.minX ?? 0, bounds.maxX);\n        obj.y = clamp(it.y + dy, bounds.minY ?? 0, bounds.maxY);\n      }\n      render();\n      return;\n    }\n\n    if (drag?.type === 'move') {\n      cancelLongPress();\n      const id = drag.id;\n      const dx = pt.x - drag.start.x;\n      const dy = pt.y - drag.start.y;\n      const bounds = currentCourtBounds();\n      const obj = objById(id);\n      if (obj) {\n        obj.x = clamp(drag.startObj.x + dx, bounds.minX ?? 0, bounds.maxX);\n        obj.y = clamp(drag.startObj.y + dy, bounds.minY ?? 0, bounds.maxY);\n      }\n      render();\n      return;\n    }\n  });\n\n  svg.addEventListener('pointerup', (e) => {\n    if (e.pointerId !== activePointerId) return;\n    e.preventDefault();\n    cancelLongPress();\n    svg.releasePointerCapture(e.pointerId);\n    activePointerId = null;\n\n    if (drag?.type === 'pending-select') {\n      setSelection(drag.id);\n      drag = null;\n      return;\n    }\n\n    if (drag?.type === 'selectbox' && selectionBox) {\n      const pt = svgPointFromClient(e.clientX, e.clientY);\n      const rect = updateSelectionRect(selectionBox.rectEl, selectionBox.start, pt);\n      selectionBox.rectEl.remove();\n      selectionBox = null;\n      const minSize = 0.2;\n      if (rect.w < minSize && rect.h < minSize) {\n        if (!drag.additive) clearSelection();\n      } else {\n        const ids = idsInRect(rect);\n        if (drag.additive) setSelection([...getSelection(), ...ids]);\n        else setSelection(ids);\n      }\n      drag = null;\n      return;\n    }\n\n    if (arrowDraft) {\n      const pt = arrowDraft.cur;\n      const s = arrowDraft.start;\n      const dist = Math.hypot(pt.x - s.x, pt.y - s.y);\n      gDrawings.removeChild(arrowDraft.pathEl);\n      if (dist > 0.35) {\n        const mx = (s.x + pt.x) / 2;\n        const my = (s.y + pt.y) / 2;\n        const d = `M ${s.x} ${s.y} Q ${mx} ${my} ${pt.x} ${pt.y}`;\n        state.drawings.push({ id: ID(), type:'arrow', team: arrowDraft.team, path: d, style:{ width:'0.12', opacity:'0.9' } });\n        setSelection(state.drawings[state.drawings.length - 1].id);\n        commit();\n      } else {\n        render();\n      }\n      arrowDraft = null;\n      return;\n    }\n\n    if (drag) {\n      if (drag.type === 'move' || drag.type === 'move-multi') commit();\n      if (drag.type === 'pan') commit();\n      if (drag.type === 'rotate' || drag.type === 'scale' || drag.type === 'rotate-group' || drag.type === 'scale-group') commit();\n      drag = null;\n    }\n  });\n\n  svg.addEventListener('dragover', (e) => {\n    e.preventDefault();\n  });\n\n  svg.addEventListener('drop', (e) => {\n    e.preventDefault();\n    const raw = e.dataTransfer.getData('application/json');\n    if (!raw) return;\n    try {\n      const data = JSON.parse(raw);\n      const pt = svgPointFromClient(e.clientX, e.clientY);\n      if (data.kind === 'player') {\n        addPlayerFromTool(data.role, pt.x, pt.y);\n      } else {\n        addProp(data.kind, pt.x, pt.y, { role: data.role, color: data.color });\n      }\n    } catch {}\n  });\n\n  svg.addEventListener('pointercancel', () => {\n    cancelLongPress();\n    arrowDraft = null;\n    if (selectionBox?.rectEl) selectionBox.rectEl.remove();\n    selectionBox = null;\n    drag = null;\n    activePointerId = null;\n    render();\n  });\n\n  // Click selection for drawings\n  svg.addEventListener('click', (e) => {\n    if (e.shiftKey) return;\n    const id = hitTestTarget(e.target);\n    if (!id) return;\n    const obj = objById(id);\n    if (obj && (obj.type === 'arrow' || obj.type === 'text')) {\n      setSelection(id);\n    }\n  }, true);\n\n  // Wheel zoom (desktop). Use Alt+wheel for zoom, wheel alone scrolls page.\n  svg.addEventListener('wheel', (e) => {\n    if (drag) return;\n    if (!e.altKey) return;\n    e.preventDefault();\n    const delta = Math.sign(e.deltaY);\n    const factor = delta > 0 ? 1.08 : 0.92;\n\n    const pt = svgPointFromClient(e.clientX, e.clientY);\n    const v = state.view;\n    const newW = clamp(v.w * factor, 8, 40);\n    const newH = newW * (v.h / v.w);\n\n    const rx = (pt.x - v.x) / v.w;\n    const ry = (pt.y - v.y) / v.h;\n\n    const nx = pt.x - rx * newW;\n    const ny = pt.y - ry * newH;\n    state.view = { x: nx, y: ny, w: newW, h: newH };\n    setViewBox(state.view);\n  }, { passive: false });\n\n  // Tap on empty to set text mode quickly if T is active\n  svg.addEventListener('dblclick', (e) => {\n    e.preventDefault();\n    const pt = svgPointFromClient(e.clientX, e.clientY);\n    if (hitTestTarget(e.target)) return;\n    addTextAt(pt.x, pt.y, 'Testo', 'A');\n    setSelection(state.texts[state.texts.length - 1].id);\n  });\n\n  // Hit test empty long press to open general menu\n  svg.addEventListener('contextmenu', (e) => {\n    e.preventDefault();\n    const targetId = hitTestTarget(e.target);\n    if (targetId) {\n      if (e.shiftKey) toggleSelection(targetId);\n      else setSelection(targetId);\n    }\n    openMenuForSelection(e.clientX, e.clientY);\n  });\n\n  stage.addEventListener('contextmenu', (e) => {\n    e.preventDefault();\n  });\n\n  window.addEventListener('pointerdown', (e) => {\n    if (!ctxMenu || ctxMenu.hidden) return;\n    if (!ctxMenu.contains(e.target)) closeContextMenu();\n  });\n\n  // Select drawings by clicking them (they are paths)\n  gDrawings.addEventListener('pointerdown', (e) => {\n    if (e.shiftKey) return;\n    const id = hitTestTarget(e.target);\n    if (id) {\n      if (getSelection().length > 1 && isSelected(id)) return;\n      setSelection(id);\n    }\n  }, true);\n\n  gPlayers.addEventListener('pointerdown', (e) => {\n    if (e.shiftKey) return;\n    const id = hitTestTarget(e.target);\n    if (id) {\n      if (getSelection().length > 1 && isSelected(id)) return;\n      setSelection(id);\n    }\n  }, true);\n\n  gProps.addEventListener('pointerdown', (e) => {\n    if (e.shiftKey) return;\n    const id = hitTestTarget(e.target);\n    if (id) {\n      if (getSelection().length > 1 && isSelected(id)) return;\n      setSelection(id);\n    }\n  }, true);\n\n  gText.addEventListener('pointerdown', (e) => {\n    if (e.shiftKey) return;\n    const id = hitTestTarget(e.target);\n    if (id) {\n      if (getSelection().length > 1 && isSelected(id)) return;\n      setSelection(id);\n    }\n  }, true);\n\n  // Save/load to localStorage for web usage\n  const LS_KEY = 'volleyboard_state_v1';\n  function saveLocal() {\n    try { localStorage.setItem(LS_KEY, JSON.stringify(state)); } catch {}\n  }\n  function loadLocal() {\n    try {\n      const raw = localStorage.getItem(LS_KEY);\n      if (!raw) return false;\n      replaceState(JSON.parse(raw));\n      return true;\n    } catch { return false; }\n  }\n  if (!EMBEDDED) {\n    window.addEventListener('beforeunload', saveLocal);\n    document.addEventListener('visibilitychange', () => { if (document.visibilityState === 'hidden') saveLocal(); });\n  }\n\n  function resetLayoutRotationsToDefaults() {\n    if (!state.layoutStates) return;\n    for (const id of Object.keys(state.layoutStates)) {\n      state.layoutStates[id].rotation = defaultRotationFor(id);\n    }\n    state.rotation = state.layoutStates[state.layout]?.rotation ?? defaultRotationFor(state.layout);\n  }\n\n  function removePlaceholderTexts() {\n    const isPlaceholder = (t) => (t.text || '') === 'Testo'\n      && (t.team || 'A') === 'A'\n      && (t.style?.size ?? 0.55) === 0.55;\n    let changed = false;\n    const lsMap = state.layoutStates || {};\n    for (const key of Object.keys(lsMap)) {\n      const ls = lsMap[key];\n      if (!Array.isArray(ls.texts)) continue;\n      const before = ls.texts.length;\n      ls.texts = ls.texts.filter((t) => !isPlaceholder(t));\n      if (before !== ls.texts.length) changed = true;\n    }\n    state.texts = lsMap[state.layout]?.texts || state.texts;\n    return changed;\n  }\n\n  // Selection / delete with long press via menu\n  // Auto-load state\n  renderToolbox();\n  const loaded = EMBEDDED ? false : loadLocal();\n  if (loaded) {\n    resetLayoutRotationsToDefaults();\n    removePlaceholderTexts();\n    render();\n  } else {\n    render();\n  }\n  updateLayoutTabs();\n\n  // Auto commit after first render to have baseline\n  pushHistory(state);\n\n  window.VOLLEY_API = {\n    getState: () => serializeState(),\n    setState: (next) => applySerializedState(next),\n    exportSvg: () => exportSvgString(),\n    subscribe: (fn) => {\n      if (typeof fn !== 'function') return () => {};\n      changeListeners.add(fn);\n      return () => changeListeners.delete(fn);\n    },\n  };\n  window.VOLLEY_READY = true;\n  try { window.dispatchEvent(new Event('volleyboard-ready')); } catch {}\n\n})();\n";

function buildSrcDoc() {
  return [
    '<!doctype html>',
    '<html lang="it">',
    '<head>',
    '<meta charset="utf-8" />',
    '<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />',
    '<style>',
    WEB_CSS,
    '</style>',
    '<script>window.VOLLEY_EMBED = true;<\/script>',
    '</head>',
    '<body>',
    WEB_HTML,
    '<script>',
    WEB_JS,
    '<\/script>',
    '</body>',
    '</html>'
  ].join('');
}

function waitForApi(iframe) {
  return new Promise((resolve) => {
    let tries = 0;
    const maxTries = 200;
    const timer = setInterval(() => {
      tries += 1;
      const win = iframe.contentWindow;
      if (win && win.VOLLEY_API) {
        clearInterval(timer);
        resolve(win.VOLLEY_API);
        return;
      }
      if (tries > maxTries) {
        clearInterval(timer);
        resolve(null);
      }
    }, 50);
  });
}

class VolleyBoardPlugin extends Plugin {
  async onload() {
    this.registerMarkdownCodeBlockProcessor('volleyboard', async (source, el, ctx) => {
      el.empty();
      const wrapper = el.createDiv({ cls: 'vb-obsidian-wrapper' });
      const style = document.createElement('style');
      style.textContent = `
        .vb-obsidian-wrapper{display:block;}
        .vb-snapshot{display:inline-block;line-height:0;border-radius:18px;overflow:hidden;border:1px solid rgba(255,255,255,.08);box-shadow:0 10px 30px rgba(0,0,0,.35);width:340px;max-width:100%;}
        .vb-snapshot svg{display:block;width:100% !important;height:auto !important;max-width:100% !important;}
        .vb-notes{margin-top:8px;font-size:12px;color:rgba(255,255,255,.7);white-space:pre-wrap;}
        .vb-error{color:rgba(255,255,255,.75);padding:8px;}
        .vb-editor-frame{width:100%;height:100%;border:0;border-radius:0;}
      `;
      wrapper.appendChild(style);

      const snap = wrapper.createDiv({ cls: 'vb-snapshot' });

      let parsed = null;
      try { parsed = JSON.parse(source.trim() || '{}'); } catch { parsed = null; }
      if (!parsed || typeof parsed !== 'object') {
        wrapper.createEl('div', { text: 'VolleyBoard: JSON non valido.', cls: 'vb-error' });
        return;
      }
      let savedState = parsed;
      let draftState = parsed;

      const renderSnapshot = async () => {
        snap.textContent = '';
        const iframe = document.createElement('iframe');
        iframe.setAttribute('sandbox', 'allow-scripts allow-same-origin');
        iframe.setAttribute('loading', 'lazy');
        iframe.setAttribute('referrerpolicy', 'no-referrer');
        iframe.style.width = '0';
        iframe.style.height = '0';
        iframe.style.border = '0';
        iframe.style.position = 'absolute';
        iframe.style.opacity = '0';
        iframe.style.pointerEvents = 'none';
        iframe.srcdoc = buildSrcDoc();
        wrapper.appendChild(iframe);

        const api = await waitForApi(iframe);
        if (!api) {
          snap.textContent = 'VolleyBoard: errore inizializzazione.';
          iframe.remove();
          return;
        }
        api.setState(savedState);
        const svg = api.exportSvg ? api.exportSvg() : '';
        iframe.remove();
        if (!svg) {
          snap.textContent = 'VolleyBoard: snapshot non disponibile.';
          return;
        }
        snap.innerHTML = svg;
      };

      await renderSnapshot();

      let editorOpen = false;
      let editorIframe = null;
      let editorLeaf = null;
      const sectionInfo = ctx.getSectionInfo?.(ctx.el);
      const blockLineStart = (sectionInfo && typeof sectionInfo.lineStart === 'number') ? sectionInfo.lineStart : null;
      const ensureBlockId = () => {
        if (!parsed) return null;
        if (!parsed.meta) parsed.meta = { createdAt: new Date().toISOString() };
        if (!parsed.meta.blockId) {
          parsed.meta.blockId = `vb_${Date.now().toString(36)}_${Math.random().toString(36).slice(2, 8)}`;
        }
        return parsed.meta.blockId;
      };
      let sourceText = source;
      const blockId = ensureBlockId();
      const refreshSourceText = (state) => {
        try { sourceText = JSON.stringify(state, null, 2); } catch {}
      };
      const persistSafe = async (nextState, strict = false) => {
        try {
          await this.persistState(ctx, sourceText, nextState, { blockLineStart, blockId, strict });
          refreshSourceText(nextState);
          return;
        } catch (err) {
          if (!strict || !String(err?.message || '').includes('blockId not found')) throw err;
        }
        // Retry once: write with lineStart (if blockId missing), then strict save.
        await this.persistState(ctx, sourceText, nextState, { blockLineStart, forceLineStart: true });
        refreshSourceText(nextState);
        await this.persistState(ctx, sourceText, nextState, { blockLineStart, blockId, strict: true });
        refreshSourceText(nextState);
      };
      const openEditor = async () => {
        if (editorOpen) return;
        editorOpen = true;
        snap.style.display = 'none';

        const iframe = document.createElement('iframe');
        editorIframe = iframe;
        iframe.className = 'vb-editor-frame';
        iframe.setAttribute('sandbox', 'allow-scripts allow-same-origin');
        iframe.setAttribute('loading', 'lazy');
        iframe.setAttribute('referrerpolicy', 'no-referrer');
        iframe.srcdoc = buildSrcDoc();

        let hostEl = null;
        const leaf = this.app.workspace.getLeaf?.('tab');
        if (leaf) {
          editorLeaf = leaf;
          await leaf.setViewState({ type: 'empty', state: {} });
          hostEl = leaf.view.containerEl;
          hostEl.empty();
          hostEl.style.padding = '0';
          hostEl.style.margin = '0';
          hostEl.style.width = '100%';
          hostEl.style.height = '100%';
          hostEl.style.display = 'flex';
          hostEl.style.flexDirection = 'column';
          iframe.style.flex = '1 1 auto';
        } else {
          hostEl = wrapper;
        }
        hostEl.appendChild(iframe);

        const api = await waitForApi(iframe);
        if (!api) {
          wrapper.createEl('div', { text: 'VolleyBoard: impossibile inizializzare.', cls: 'vb-error' });
          return;
        }

        api.setState(savedState);

        let dirty = false;
        let btnSaveClose = null;
        const setDirty = (value) => {
          dirty = value;
          if (btnSaveClose) btnSaveClose.textContent = dirty ? 'Salva e chiudi*' : 'Salva e chiudi';
        };

        const scheduleSave = (nextState) => {
          draftState = nextState;
          setDirty(true);
        };

        api.subscribe(scheduleSave);

        const controls = document.createElement('div');
        controls.style.display = 'flex';
        controls.style.gap = '8px';
        controls.style.padding = '10px';
        controls.style.background = 'rgba(0,0,0,0.35)';
        controls.style.borderBottom = '1px solid rgba(255,255,255,0.08)';

        btnSaveClose = document.createElement('button');
        btnSaveClose.textContent = 'Salva e chiudi';
        btnSaveClose.addEventListener('click', async () => {
          try {
            const latest = api.getState ? api.getState() : draftState;
            savedState = latest;
            parsed = savedState;
          } catch {}
          try {
            await persistSafe(savedState, false);
            setDirty(false);
          } catch (e) {
            console.error(e);
            new Notice('VolleyBoard: impossibile salvare (vedi console)');
          }
          if (editorIframe) editorIframe.remove();
          controls.remove();
          if (editorLeaf) {
            editorLeaf.detach();
            editorLeaf = null;
          }
          editorOpen = false;
          // Refresh snapshot after save
          if (wrapper.isConnected) {
            snap.style.display = '';
            await renderSnapshot();
          }
        });
        controls.appendChild(btnSaveClose);

        const btnDiscard = document.createElement('button');
        btnDiscard.textContent = 'Annulla';
        btnDiscard.addEventListener('click', async () => {
          if (editorIframe) editorIframe.remove();
          controls.remove();
          if (editorLeaf) {
            editorLeaf.detach();
            editorLeaf = null;
          }
          editorOpen = false;
          draftState = savedState;
          setDirty(false);
          if (wrapper.isConnected) {
            snap.style.display = '';
            await renderSnapshot();
          }
        });
        controls.appendChild(btnDiscard);

        if (hostEl && hostEl !== wrapper) {
          hostEl.prepend(controls);
        } else {
          wrapper.insertBefore(controls, iframe);
        }
      };

      wrapper.addEventListener('click', (e) => {
        if (editorOpen) return;
        openEditor();
      });
    });

    this.addCommand({
      id: 'insert-volleyboard-block',
      name: 'Insert VolleyBoard block',
      editorCallback: (editor) => {
        const block = {
          version: 1,
          meta: { createdAt: new Date().toISOString() },
          layout: 'full-h',
          rotation: 0,
          view: { x: -2, y: -2, w: 22, h: 13 },
          notes: '',
          layers: { players: true, drawings: true, text: true },
          objects: [],
          drawings: [],
          texts: [],
          props: [],
        };
        const md = '```volleyboard\n' + JSON.stringify(block, null, 2) + '\n```\n';
        editor.replaceSelection(md);
      }
    });
  }

  onunload() {}

  async persistState(ctx, originalSource, nextState, opts = {}) {
    const file = ctx.sourcePath ? this.app.vault.getAbstractFileByPath(ctx.sourcePath) : null;
    if (!file) throw new Error('No file from context');

    const text = await this.app.vault.read(file);
    const normalizedText = text.replace(/\r\n/g, '\n');
    const replacement = '```volleyboard\n' + JSON.stringify(nextState, null, 2) + '\n```';
    const stableStringify = (value) => {
      if (value === null || typeof value !== 'object') return JSON.stringify(value);
      if (Array.isArray(value)) return '[' + value.map((v) => stableStringify(v)).join(',') + ']';
      const keys = Object.keys(value).sort();
      return '{' + keys.map((k) => JSON.stringify(k) + ':' + stableStringify(value[k])).join(',') + '}';
    };
    const normalizeJsonForMatch = (jsonText) => {
      try {
        const obj = JSON.parse(jsonText);
        if (obj && typeof obj === 'object' && obj.meta && typeof obj.meta === 'object') {
          const next = { ...obj, meta: { ...obj.meta } };
          delete next.meta.blockId;
          return stableStringify(next);
        }
        return stableStringify(obj);
      } catch {
        return null;
      }
    };

    const section = ctx.getSectionInfo?.(ctx.el);
    if (typeof opts?.blockLineStart !== 'number') {
      const lineStart = (section && typeof section.lineStart === 'number') ? section.lineStart : null;
      if (typeof lineStart === 'number') opts.blockLineStart = lineStart;
    }
    {
      const lines = normalizedText.split('\n');
      const blocks = [];
      let i = 0;
      while (i < lines.length) {
        const openLine = lines[i];
        const openTrim = openLine.trim();
        if (openTrim === '```volleyboard') {
          const start = i;
          const indent = openLine.match(/^(\s*)/)?.[1] ?? '';
          i += 1;
          const contentStart = i;
          while (i < lines.length && lines[i].trim() !== '```') i += 1;
          const end = Math.min(i, lines.length - 1);
          const content = lines.slice(contentStart, end).map((line) => {
            if (indent && line.startsWith(indent)) return line.slice(indent.length);
            return line;
          }).join('\n').trim();
          let parsedId = null;
          let parsedNorm = null;
          try {
            const parsedObj = JSON.parse(content);
            parsedId = parsedObj?.meta?.blockId ?? null;
            parsedNorm = normalizeJsonForMatch(content);
          } catch {}
          blocks.push({ start, end, content, indent, parsedId, parsedNorm });
        }
        i += 1;
      }
      let match = null;
      const blockId = opts?.blockId;
      const originalNorm = normalizeJsonForMatch(originalSource || '');
      if (blockId) {
        for (const b of blocks) {
          if (b.parsedId === blockId) { match = b; break; }
        }
        if (!match && opts?.strict && typeof opts?.blockLineStart === 'number') {
          const line = opts.blockLineStart;
          const candidate = blocks.find((b) => line >= b.start && line <= b.end);
          if (candidate) {
            const candidateId = candidate.parsedId;
            if (candidateId && candidateId !== blockId) {
              throw new Error('VolleyBoard: blockId not found');
            }
            match = candidate;
          }
        }
        if (!match && opts?.strict) {
          const candidate = originalNorm ? blocks.find((b) => b.parsedNorm && b.parsedNorm === originalNorm) : null;
          if (candidate) {
            const candidateId = candidate.parsedId;
            if (candidateId && candidateId !== blockId) {
              throw new Error('VolleyBoard: blockId not found');
            }
            match = candidate;
          }
        }
        if (!match && opts?.strict) throw new Error('VolleyBoard: blockId not found');
      }
      if (!match && opts?.forceLineStart && typeof opts?.blockLineStart === 'number') {
        const line = opts.blockLineStart;
        match = blocks.find((b) => line >= b.start && line <= b.end);
        if (!match && opts?.strict) throw new Error('VolleyBoard: block line not found');
      }
      if (!match && typeof opts?.blockLineStart === 'number') {
        const line = opts.blockLineStart;
        match = blocks.find((b) => line >= b.start && line <= b.end);
      }
      if (!match && !opts?.strict) {
        const norm = (s) => (s || '').trim();
        const target = norm(originalSource);
        match = blocks.find((b) => norm(b.content) === target);
      }
      if (match) {
        const replLines = replacement.split('\n').map((line) => (match.indent ? `${match.indent}${line}` : line));
        lines.splice(match.start, match.end - match.start + 1, ...replLines);
        await this.app.vault.modify(file, lines.join('\n'));
        return;
      }
    }

    const re = /```volleyboard\s*([\s\S]*?)```/m;
    const m = text.match(re);
    if (!m) throw new Error('No volleyboard block found');
    const nextText = text.replace(re, replacement);
    await this.app.vault.modify(file, nextText);
  }
}

module.exports = VolleyBoardPlugin;
